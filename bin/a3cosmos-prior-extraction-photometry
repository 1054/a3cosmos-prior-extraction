#!/bin/bash
# 
# 
# Last update:
#     2017-12-06 dzliu: rename functions
#     2018-11-27 dzliu: added more options: -galfit-prior-*
# 
# 
# Description:
#     THe aim of this code is to perform prior-based source fitting photometry in a big image. 
#     This code will automatically cut the big image into small boxes and do the photometry in each box. Boxes are extended to have buffer area. 
#     This code will call galfit iteratively to fit prior sources to the cutout data. 
# 


# 
# Print Usage
# 
if [[ $# -eq 0 ]]; then
    echo "Usage: "
    echo "    a3cosmos-prior-extraction-photometry -catalog Catalog.fits"
    echo "    a3cosmos-prior-extraction-photometry -catalog Catalog.fits -sci XXX.fits -rms XXX.fits -psf XXX.fits -pba XXX.fits"
    echo "    a3cosmos-prior-extraction-photometry -catalog Catalog.fits -sci XXX.fits -rms XXX.fits -psf XXX.fits -pba XXX.fits -fit-sky -galfit-prior-peak-snr 0.5 -galfit-prior-total-snr 1.5"
    echo "Options:"
    echo "    -output-dir # output folder name, default is \"Prior_Extraction_Photometry_v<DATE>\""
    echo "    -output-name # output subfolder name, default is the input image name without suffix"
    echo "Notes:"
    echo "    Please run \"a3cosmos-prior-extraction-photometry-read-results\" after running this. You will find some ASCII-format output catalogs under the output directory!"
    exit
fi



# 
# Check software dependancies
# 
script_dir=$(cd $(dirname "${BASH_SOURCE[0]}"); pwd)
if [[ -f $(dirname "$script_dir")/SETUP.bash ]]; then
    ALMACOSMOS_SETUP_SCRIPT=$(dirname "$script_dir")/SETUP.bash
    source "$ALMACOSMOS_SETUP_SCRIPT"
else
    echo "Error! \""$(dirname "$script_dir")/SETUP.bash"\" was not found! Please download the entire package of this code from \"https://github.com/1054/a3cosmos-prior-extraction\" then re-run this pipeline!"
    exit 1
fi

#if [[ -f "$HOME/Cloud/Github/DeepFields.SuperDeblending/Softwares/SETUP" ]]; then
#    source "$HOME/Cloud/Github/DeepFields.SuperDeblending/Softwares/SETUP"
#else
#    echo "Error! \"$HOME/Cloud/Github/DeepFields.SuperDeblending/Softwares/SETUP\" was not found! Please download from \"https://github.com/1054/DeepFields.SuperDeblending\"!"
#    exit 1
#fi

#if [[ -f "$HOME/Softwares/Supermongo/bin_setup.bash" ]]; then
#    source "$HOME/Softwares/Supermongo/bin_setup.bash"
#fi



# 
# Check software dependancies
# 
if [[ $(type smdl 2>/dev/null | wc -l) -eq 0 ]]; then
    echo "Error! \"smdl\" is not in the \$PATH! Please add its path to the \$PATH then re-run this code!"
    exit 255
fi
if [[ $(type sky2xy 2>/dev/null | wc -l) -eq 0 ]]; then
    echo "Error! \"sky2xy\" is not in the \$PATH! Please add its path to the \$PATH then re-run this code!"
    exit 255
fi
if [[ $(type galfit 2>/dev/null | wc -l) -eq 0 ]]; then
    echo "Error! \"galfit\" is not in the \$PATH! Please add its path to the \$PATH then re-run this code!"
    exit 255
fi
if [[ $(type astrodepth_prior_extraction_photometry 2>/dev/null | wc -l) -eq 0 ]]; then
    echo "Error! \"astrodepth_prior_extraction_photometry\" is not in the \$PATH! Please add its path to the \$PATH then re-run this code!"
    exit 255
fi



# 
# Read user input
# 
UserFitStart=""
UserFitEnd=""
UserYes=0
UserSteps=()
UserUnlock=()
UserOverwrite=()
UserCutBuffer=20
UserFitWithGalfit30=0
UserFitWithGalfit255=0
UserFitSkyBackground=0
UserClean=0
InputCat=()
InputSci=()
InputPsf=()
InputRms=()
InputPba=()
InputBoxSize=()
InputGalfitPriorPeakSNR=()
InputGalfitPriorTotalSNR=()
InputGalfitVaryMagErr=()
InputGalfitVaryTotRMS=()
InputGalfitFitGaussianMagErr=()
InputGalfitFitGaussianTotRMS=()
InputGalfitFitSersicMagErr=()
InputGalfitFitSersicTotRMS=()
OutputDir="Prior_Extraction_Photometry_v"$(date +"%Y%m%d")
OutputSubDir="astrodepth_prior_extraction_photometry"
while [[ "$#" -gt 0 ]]; do
    #echo $1
    TempStr=$(echo "$1" | tr '[:upper:]' '[:lower:]')
    #echo $TempStr
    case "$TempStr" in
                                          "-start") CAAP_CMD_TEXT="$1"; shift; CAAP_CMD_TYPE="start";;
                                            "-end") CAAP_CMD_TEXT="$1"; shift; CAAP_CMD_TYPE="end";;
                                            "-cat") CAAP_CMD_TEXT="$1"; shift; CAAP_CMD_TYPE="catalog";;
                                        "-catalog") CAAP_CMD_TEXT="$1"; shift; CAAP_CMD_TYPE="catalog";;
                                            "-inp") CAAP_CMD_TEXT="$1"; shift; CAAP_CMD_TYPE="list-image-sci";;
                                            "-sci") CAAP_CMD_TEXT="$1"; shift; CAAP_CMD_TYPE="list-image-sci";;
                                           "-fits") CAAP_CMD_TEXT="$1"; shift; CAAP_CMD_TYPE="list-image-sci";;
                                          "-image") CAAP_CMD_TEXT="$1"; shift; CAAP_CMD_TYPE="list-image-sci";;
                                            "-psf") CAAP_CMD_TEXT="$1"; shift; CAAP_CMD_TYPE="list-image-psf";;
                                            "-rms") CAAP_CMD_TEXT="$1"; shift; CAAP_CMD_TYPE="list-image-rms";;
                                            "-pba") CAAP_CMD_TEXT="$1"; shift; CAAP_CMD_TYPE="list-image-pba";; # primary beam attenuation file
                                            "-pbc") CAAP_CMD_TEXT="$1"; shift; CAAP_CMD_TYPE="list-image-pba";; # primary beam attenuation file
                                             "-pb") CAAP_CMD_TEXT="$1"; shift; CAAP_CMD_TYPE="list-image-pba";; # primary beam attenuation file
                                      "-image-sci") CAAP_CMD_TEXT="$1"; shift; CAAP_CMD_TYPE="list-image-sci";;
                                      "-image-psf") CAAP_CMD_TEXT="$1"; shift; CAAP_CMD_TYPE="list-image-psf";;
                                      "-image-rms") CAAP_CMD_TEXT="$1"; shift; CAAP_CMD_TYPE="list-image-rms";;
                                      "-image-pba") CAAP_CMD_TEXT="$1"; shift; CAAP_CMD_TYPE="list-image-pba";; # primary beam attenuation file
                                      "-image-pbc") CAAP_CMD_TEXT="$1"; shift; CAAP_CMD_TYPE="list-image-pba";; # primary beam attenuation file
                                       "-image-pb") CAAP_CMD_TEXT="$1"; shift; CAAP_CMD_TYPE="list-image-pba";; # primary beam attenuation file
                                      "-overwrite") CAAP_CMD_TEXT="$1"; shift; CAAP_CMD_TYPE="user-overwrite";;
                                           "-step") CAAP_CMD_TEXT="$1"; shift; CAAP_CMD_TYPE="user-steps";;
                                          "-steps") CAAP_CMD_TEXT="$1"; shift; CAAP_CMD_TYPE="user-steps";;
                                         "-unlock") CAAP_CMD_TEXT="$1"; shift; CAAP_CMD_TYPE="user-unlock";;
                                            "-out") CAAP_CMD_TEXT="$1"; shift; CAAP_CMD_TYPE="output-dir";;
                                         "-output") CAAP_CMD_TEXT="$1"; shift; CAAP_CMD_TYPE="output-dir";;
                                      "-outputdir") CAAP_CMD_TEXT="$1"; shift; CAAP_CMD_TYPE="output-dir";;
                                     "-output-dir") CAAP_CMD_TEXT="$1"; shift; CAAP_CMD_TYPE="output-dir";;
                                    "-output-name") CAAP_CMD_TEXT="$1"; shift; CAAP_CMD_TYPE="output-name";;
                                  "-output-subdir") CAAP_CMD_TEXT="$1"; shift; CAAP_CMD_TYPE="output-name";;
                                 "-output-sub-dir") CAAP_CMD_TEXT="$1"; shift; CAAP_CMD_TYPE="output-name";;
                                            "-box") CAAP_CMD_TEXT="$1"; shift; CAAP_CMD_TYPE="box-size";;
                                       "-box-size") CAAP_CMD_TEXT="$1"; shift; CAAP_CMD_TYPE="box-size";;
                                            "-yes") CAAP_CMD_TEXT="$1";        CAAP_CMD_TYPE="yes";;
                                          "-clean") CAAP_CMD_TEXT="$1";        CAAP_CMD_TYPE="clean";;
                                       "-galfit30") CAAP_CMD_TEXT="$1";        CAAP_CMD_TYPE="galfit30";;
                                      "-galfit255") CAAP_CMD_TEXT="$1";        CAAP_CMD_TYPE="galfit255";;
                                        "-fit-sky") CAAP_CMD_TEXT="$1";        CAAP_CMD_TYPE="fit-sky";;
                                    "-no-galfit30") CAAP_CMD_TEXT="$1";        CAAP_CMD_TYPE="no-galfit30";;
                                   "-no-galfit255") CAAP_CMD_TEXT="$1";        CAAP_CMD_TYPE="no-galfit255";;
                                 "-do-not-fit-sky") CAAP_CMD_TEXT="$1";        CAAP_CMD_TYPE="do-not-fit-sky";;
                          "-galfit-prior-peak-snr") CAAP_CMD_TEXT="$1"; shift; CAAP_CMD_TYPE="galfit-prior-peak-snr";;
                         "-galfit-prior-total-snr") CAAP_CMD_TEXT="$1"; shift; CAAP_CMD_TYPE="galfit-prior-total-snr";;
    "-galfit-prior-vary-position-threshold-magerr") CAAP_CMD_TEXT="$1"; shift; CAAP_CMD_TYPE="galfit-prior-vary-position-threshold-magerr";;
    "-galfit-prior-vary-position-threshold-totrms") CAAP_CMD_TEXT="$1"; shift; CAAP_CMD_TYPE="galfit-prior-vary-position-threshold-totrms";;
      "-galfit-prior-vary-position-maximum-arcsec") CAAP_CMD_TEXT="$1"; shift; CAAP_CMD_TYPE="galfit-prior-vary-position-maximum-arcsec";;
    esac
    #echo "$CAAP_CMD_TYPE"
    case "$CAAP_CMD_TYPE" in
                                           "start") if [[ $# -gt 0 ]]; then UserFitStart="$1"; fi;;
                                             "end") if [[ $# -gt 0 ]]; then UserFitEnd="$1"; fi;;
                                         "catalog") if [[ $# -gt 0 ]]; then InputCat+=("$1"); fi;;
                                  "list-image-sci") if [[ $# -gt 0 ]]; then InputSci+=("$1"); fi;;
                                  "list-image-psf") if [[ $# -gt 0 ]]; then InputPsf+=("$1"); fi;;
                                  "list-image-rms") if [[ $# -gt 0 ]]; then InputRms+=("$1"); fi;;
                                  "list-image-pba") if [[ $# -gt 0 ]]; then InputPba+=("$1"); fi;;
                                        "box-size") if [[ $# -gt 0 ]]; then InputBoxSize+=("$1"); fi;;
                                      "output-dir") if [[ $# -gt 0 ]]; then OutputDir="$1"; fi;;
                                     "output-name") if [[ $# -gt 0 ]]; then OutputSubDir="$1"; fi;;
                                      "user-steps") if [[ $# -gt 0 ]]; then UserSteps+=("$1"); fi;;
                                     "user-unlock") if [[ $# -gt 0 ]]; then UserUnlock+=("$1"); fi;;
                                  "user-overwrite") if [[ $# -gt 0 ]]; then UserOverwrite+=("$1"); fi;;
                                        "galfit30")                         UserFitWithGalfit30=1;; #<20170919># added to allow use galfit30, which is more useful for IRAC images.
                                       "galfit255")                         UserFitWithGalfit255=1;; #<20170919># added to allow use galfit255, which is more useful for IRAC images.
                                         "fit-sky")                         UserFitSkyBackground=1;; #<20170919># added to allow fit sky background, which is important for IRAC images. 
                                     "no-galfit30")                         UserFitWithGalfit30=-1;; #<20170919># added to allow to not use galfit30, which is more useful for IRAC images.
                                    "no-galfit255")                         UserFitWithGalfit255=-1;; #<20170919># added to allow to not use galfit255, which is more useful for IRAC images.
                                  "do-not-fit-sky")                         UserFitSkyBackground=-1;; #<20170919># added to allow to not fit sky background, which is important for IRAC images. 
                           "galfit-prior-peak-snr") if [[ $# -gt 0 ]]; then InputGalfitPriorPeakSNR+=("$1"); fi;; #<20170923># allow to set the peak snr threshold for selecting galfit prior from getpix candidates
                          "galfit-prior-total-snr") if [[ $# -gt 0 ]]; then InputGalfitPriorTotalSNR+=("$1"); fi;; #<20170923># allow to set the total snr threshold for selecting galfit prior from getpix candidates
     "galfit-prior-vary-position-threshold-magerr") if [[ $# -gt 0 ]]; then InputGalfitVaryMagErr+=("$1"); fi;; #<20171127># allow to set the threshold for varying prior position
     "galfit-prior-vary-position-threshold-totrms") if [[ $# -gt 0 ]]; then InputGalfitVaryTotRMS+=("$1"); fi;; #<20171127># allow to set the threshold for varying prior position
       "galfit-prior-vary-position-maximum-arcsec") if [[ $# -gt 0 ]]; then InputGalfitVaryMaxArcsec+=("$1"); fi;; #<20191023># allow to set the maximum angular distance in units of arcsec for varying prior position
                                             "yes")                         UserYes=1;;
                                           "clean")                         UserClean=$((UserClean+1));;
    esac
    #
    if [[ $# -gt 0 ]]; then shift; fi
done

if [[ ${#UserOverwrite[@]} -eq 0 ]]; then
    UserOverwrite=("none")
fi
if [[ ${#UserUnlock[@]} -eq 0 ]]; then
    UserUnlock=("none")
fi

echo "UserFitStart = $UserFitStart"
echo "UserFitEnd = $UserFitEnd"
echo "UserSteps = ${UserSteps[@]}"
echo "UserUnlock = ${UserUnlock[@]}"
echo "UserOverwrite = ${UserOverwrite[@]}"
echo "InputCat = ${InputCat[@]} (${#InputCat[@]})"
echo "InputSci = ${InputSci[@]} (${#InputSci[@]})"
echo "InputPsf = ${InputPsf[@]} (${#InputPsf[@]})"
echo "InputRms = ${InputRms[@]} (${#InputRms[@]})"
echo "InputPba = ${InputPba[@]} (${#InputPba[@]})"



# 
# Check output dir
# 
if [[ ! -d "$OutputDir" ]]; then
    mkdir -p "$OutputDir"
fi
if [[ ! -d "$OutputDir" ]]; then
    echo "Error! Failed to create output directory \"$OutputDir\"! Abort!"; exit 1
fi
if [[ ! -d "$OutputDir/$OutputSubDir" ]]; then
    mkdir -p "$OutputDir/$OutputSubDir"
fi



# 
# Check Input Catalog
# 
if [[ ${#InputCat[@]} -gt 0 ]]; then
    if [[ -f "$OutputDir/List_of_Input_Catalog.txt" ]]; then
        mv "$OutputDir/List_of_Input_Catalog.txt" "$OutputDir/List_of_Input_Catalog.txt.backup"
    fi
    InputCats=()
    for (( i=0; i<${#InputCat[@]}; i++ )); do
        if [[ ! -f "${InputCat[i]}" ]]; then
            echo "Error! The input catalog \"${InputCat[i]}\" does not exist!"; exit 1
        fi
        #if [[ "${InputCat[i]}" != *".fits" ]]; then
        #    echo "Error! The input catalog \"${InputCat[i]}\" is not a FITS format data table!"; exit 1
        #fi
        InputCat1=$(almacosmos_get_absolute_file_path "${InputCat[i]}") # get full path
        InputCats+=("$InputCat1")
        echo "$InputCat1" > "$OutputDir/List_of_Input_Catalog.txt"
    done
fi



# 
# Check Input Sci Fits Image List
# 
if [[ ${#InputSci[@]} -gt 0 ]]; then
    if [[ -f "$OutputDir/List_of_Input_Sci_Images.txt" ]]; then
        mv "$OutputDir/List_of_Input_Sci_Images.txt" "$OutputDir/List_of_Input_Sci_Images.txt.backup"
    fi
    if [[ -f "$OutputDir/List_of_Input_Rms_Images.txt" ]]; then
        mv "$OutputDir/List_of_Input_Rms_Images.txt" "$OutputDir/List_of_Input_Rms_Images.txt.backup"
    fi
    if [[ -f "$OutputDir/List_of_Input_Pba_Images.txt" ]]; then
        mv "$OutputDir/List_of_Input_Pba_Images.txt" "$OutputDir/List_of_Input_Pba_Images.txt.backup"
    fi
    if [[ -f "$OutputDir/List_of_Input_Psf_Images.txt" ]]; then
        mv "$OutputDir/List_of_Input_Psf_Images.txt" "$OutputDir/List_of_Input_Psf_Images.txt.backup"
    fi
    SciImages=()
    for (( i=0; i<${#InputSci[@]}; i++ )); do
        # if the input is a "txt" file, then read in as a list
        if [[ "${InputSci[i]}" == *".txt" ]]; then
            Old_IFS=$IFS
            IFS=$'\n' read -d '' -r -a SciImage1 < "${InputSci[i]}"
            IFS="$Old_IFS"
            for (( j=0; j<${#SciImage1[@]}; j++ )); do
                if [[ "${SciImage1[j]}" != "/"* ]]; then
                    SciImage1[j]=$(dirname "${InputSci[i]}")"/${SciImage1[j]}"
                fi
                if [[ -f "${SciImage1[j]}" ]]; then
                    SciImages+=($(almacosmos_get_absolute_file_path "${SciImage1[j]}"))
                else
                    echo "Error! InputSci \"${SciImage1[j]}\" does not exist!"; exit 1
                fi
            done
        elif [[ "${InputSci[i]}" == *".fits" ]]; then
            if [[ -f "${InputSci[i]}" ]]; then
                SciImages+=($(almacosmos_get_absolute_file_path "${InputSci[i]}"))
            else
                echo "Error! InputSci \"${InputSci[i]}\" does not exist!"; exit 1
            fi
        fi
    done
fi



# 
# Check Input Psf Fits Image List
# 
if [[ ${#InputPsf[@]} -gt 0 ]]; then
    if [[ -f "$OutputDir/List_of_Input_Psf_Images.txt" ]]; then
        mv "$OutputDir/List_of_Input_Psf_Images.txt" "$OutputDir/List_of_Input_Psf_Images.txt.backup"
    fi
    PsfImages=()
    for (( i=0; i<${#InputPsf[@]}; i++ )); do
        # if the input is a "txt" file, then read in as a list
        if [[ "${InputPsf[i]}" == *".txt" ]]; then
            Old_IFS=$IFS
            IFS=$'\n' read -d '' -r -a PsfImage1 < "${InputPsf[i]}"
            IFS="$Old_IFS"
            for (( j=0; j<${#PsfImage1[@]}; j++ )); do
                if [[ "${PsfImage1[j]}" != "/"* ]]; then
                    PsfImage1[j]=$(dirname "${InputPsf[i]}")"/${PsfImage1[j]}"
                fi
                if [[ -f "${PsfImage1[j]}" ]]; then
                    PsfImages+=($(almacosmos_get_absolute_file_path "${PsfImage1[j]}"))
                else
                    echo "Error! InputPsf \"${PsfImage1[j]}\" does not exist!"; exit 1
                fi
            done
        elif [[ "${InputPsf[i]}" == *".fits" ]]; then
            if [[ -f "${InputPsf[i]}" ]]; then
                PsfImages+=($(almacosmos_get_absolute_file_path "${InputPsf[i]}"))
            else
                echo "Error! InputPsf \"${InputPsf[i]}\" does not exist!"; exit 1
            fi
        fi
    done
else
    PsfImages=()
fi



# 
# Check Input Rms Fits Image List
# 
if [[ ${#InputRms[@]} -gt 0 ]]; then
    if [[ -f "$OutputDir/List_of_Input_Rms_Images.txt" ]]; then
        mv "$OutputDir/List_of_Input_Rms_Images.txt" "$OutputDir/List_of_Input_Rms_Images.txt.backup"
    fi
    RmsImages=()
    for (( i=0; i<${#InputRms[@]}; i++ )); do
        # if the input is a "txt" file (containing the path of the fits image), then read in as a list
        if [[ "${InputRms[i]}" == *".txt" ]]; then
            Old_IFS=$IFS
            IFS=$'\n' read -d '' -r -a RmsImage1 < "${InputRms[i]}"
            IFS="$Old_IFS"
            for (( j=0; j<${#RmsImage1[@]}; j++ )); do
                if [[ "${RmsImage1[j]}" != "/"* ]]; then
                    RmsImage1[j]=$(dirname "${InputRms[i]}")"/${RmsImage1[j]}"
                fi
                if [[ -f "${RmsImage1[j]}" ]]; then
                    RmsImages+=($(almacosmos_get_absolute_file_path "${RmsImage1[j]}"))
                else
                    echo "Error! InputRms \"${RmsImage1[j]}\" does not exist!"; exit 1
                fi
            done
        elif [[ "${InputRms[i]}" == *".fits" ]]; then
            if [[ -f "${InputRms[i]}" ]]; then
                RmsImages+=($(almacosmos_get_absolute_file_path "${InputRms[i]}"))
            else
                echo "Error! InputRms \"${InputRms[i]}\" does not exist!"; exit 1
            fi
        fi
    done
fi



# 
# Check Input Pba Fits Image List
# 
if [[ ${#InputPba[@]} -gt 0 ]]; then
    if [[ -f "$OutputDir/List_of_Input_Pba_Images.txt" ]]; then
        mv "$OutputDir/List_of_Input_Pba_Images.txt" "$OutputDir/List_of_Input_Pba_Images.txt.backup"
    fi
    PbaImages=()
    for (( i=0; i<${#InputPba[@]}; i++ )); do
        # if the input is a "txt" file (containing the path of the fits image), then read in as a list
        if [[ "${InputPba[i]}" == *".txt" ]]; then
            Old_IFS=$IFS
            IFS=$'\n' read -d '' -r -a PbaImage1 < "${InputPba[i]}"
            IFS="$Old_IFS"
            for (( j=0; j<${#PbaImage1[@]}; j++ )); do
                if [[ "${PbaImage1[j]}" != "/"* ]]; then
                    PbaImage1[j]=$(dirname "${InputPba[i]}")"/${PbaImage1[j]}"
                fi
                if [[ -f "${PbaImage1[j]}" ]]; then
                    PbaImages+=($(almacosmos_get_absolute_file_path "${PbaImage1[j]}"))
                else
                    echo "Error! InputPba \"${PbaImage1[j]}\" does not exist!"; exit 1
                fi
            done
        elif [[ "${InputPba[i]}" == *".fits" ]]; then
            if [[ -f "${InputPba[i]}" ]]; then
                PbaImages+=($(almacosmos_get_absolute_file_path "${InputPba[i]}"))
            else
                echo "Error! InputPba \"${InputPba[i]}\" does not exist!"; exit 1
            fi
        fi
    done
else
    PbaImages=()
fi



# 
# Load sci and psf fits file list
# 
echo "Loading SciImages and PsfImages ... "
#ls "$OutputDir/List_of_Input_Sci_Images.txt"
#ls "$OutputDir/List_of_Input_Psf_Images.txt"
if [[ ! -f "$OutputDir/List_of_Input_Sci_Images.txt" || ! -f "$OutputDir/List_of_Input_Psf_Images.txt" ]]; then
    # 
    # Check SciImages
    if [[ ${#SciImages[@]} -eq 0 ]]; then
        echo "Error! No Sci Fits Image was given! Please input the list of Sci Fits Image by \"-image\" or \"-image-sci\" argument!"; exit 1
    fi
    # 
    # Loop SciImages
    for (( i=0; i<${#SciImages[@]}; i++ )); do
        # 
        # print progress
        if [[ ${#SciImages[@]} -ge 10 ]]; then
            if [[ $(awk "BEGIN {print (($i)%(int(${#SciImages[@]}/10)))}") -eq 0 ]]; then
                printf "\r %-100s [%5.1f%%]" $(basename "${SciImages[i]}") $(awk "BEGIN {print (100.0*($i)/(${#SciImages[@]}))}")
                #echo -n $(awk "BEGIN {print (100.0*($i)/(${#SciImages[@]}))}")"% "
            fi
            if [[ $(($i+1)) -eq ${#SciImages[@]} ]]; then
                printf "\r %-100s [%5.1f%%]" $(basename "${SciImages[i]}") 100
                printf "\r %-100s %20s"
                printf "\r"
                #echo -n "100%"
            fi
        fi
        # 
        # check SciImage
        SciImage="${SciImages[i]}"
        # 
        # debug
        #<20170923># echo "\${#PsfImages[@]} = ${#PsfImages[@]}"
        #<20170923># echo "\${#RmsImages[@]} = ${#RmsImages[@]}"
        #<20170923># echo "\${#PbaImages[@]} = ${#PbaImages[@]}"
        # 
        # check PsfImage, generate one if not given
        if [[ ${#PsfImages[@]} -gt $i ]]; then
            PsfImage="${PsfImages[i]}"
        else
            # create a PsfImage with extension .clean-beam.fits, by replacing the SciImage extension .image.fits
            PsfImage=$(echo "$SciImage" | sed -e 's/\.image\.fits$/.clean-beam/g')
            # create a PsfImage with extension .clean-beam.fits, by replacing the SciImage extension .fits
            if [[ "$PsfImage" == *".fits" ]]; then
                PsfImage=$(echo "$SciImage" | sed -e 's/\.fits$/.clean-beam/g')
            fi
            if [[ ! -f "$PsfImage.fits" ]]; then
                echo "# "$(date +'%Y%m%d %Hh%Mm%Ss %Z') > "$PsfImage.log"
                echo "almacosmos_generate_PSF_Gaussian_2D.py \"$SciImage\" \"$PsfImage.fits\"" >> "$PsfImage.log"
                almacosmos_generate_PSF_Gaussian_2D.py "$SciImage" "$PsfImage.fits" >> "$PsfImage.log" 2>&1
            fi
            if [[ ! -f "$PsfImage.fits" ]]; then
                echo "Error! Failed to run \"almacosmos_generate_PSF_Gaussian_2D.py\" to create the PsfImage \"$PsfImage.fits\"!"; echo "Please check log file: $PsfImage.log"; exit 1
            fi
            PsfImage="$PsfImage.fits"
            PsfImages+=("$PsfImage")
        fi
        # 
        # check RmsImage. If not given, then generate an rms image according to "$RmsStats.txt" which is related to the "$SciImage" fits file. 
        if [[ ${#RmsImages[@]} -gt $i ]]; then
            RmsImage="${RmsImages[i]}"
        else
            RmsStats=$(echo "$SciImage" | sed -e 's/\.fits$/.fits.pixel.statistics/g')
            # check rms value from $RmsStats.txt <20170806>
            if [[ -f "$RmsStats.txt" ]]; then
                RmsValue=$(cat $RmsStats.txt | grep "^Gaussian_sigma *=" | perl -p -e 's/Gaussian_sigma *= *([0-9.+-eE]+) *.*/\1/g')
                if [[ "$RmsValue"x == ""x ]]; then
                    rm "$RmsStats.txt"
                fi
            fi
            # compute rms value with the code 'almacosmos_get_fits_image_pixel_histogram.py'
            if [[ ! -f "$RmsStats.txt" ]]; then
                echo "# "$(date +'%Y%m%d %Hh%Mm%Ss %Z') > "$RmsStats.log"
                echo "almacosmos_get_fits_image_pixel_histogram.py \"$SciImage\"" >> "$RmsStats.log"
                almacosmos_get_fits_image_pixel_histogram.py "$SciImage" >> "$RmsStats.log" 2>&1
            fi
            if [[ ! -f "$RmsStats.txt" ]]; then
                echo "Error! Failed to run \"almacosmos_get_fits_image_pixel_histogram.py\" to create the RmsStats \"$RmsStats.txt\"!"; echo "Please check log file: $RmsStats.log"; exit 1
            fi
            # create an rms image from the RmsStats
            RmsValue=$(cat $RmsStats.txt | grep "^Gaussian_sigma *=" | perl -p -e 's/Gaussian_sigma *= *([0-9.+-eE]+) *.*/\1/g')
            if [[ "$RmsValue"x == ""x ]]; then
                echo "Error! Failed to get Gaussian_sigma from \"$RmsStats.txt\"! Please check \"$RmsStats.log\"!"; exit 1
            fi
            RmsValue2=$(cat $RmsStats.txt | grep "^Inner_sigma *=" | perl -p -e 's/Inner_sigma *= *([0-9.+-eE]+) *.*/\1/g')
            if [[ "$RmsValue2"x == ""x ]]; then
                echo "Error! Failed to get Inner_sigma from \"$RmsStats.txt\"! Please check \"$RmsStats.log\"!"; exit 1
            fi
            if [[ $(awk "BEGIN {if( sqrt((($RmsValue)-($RmsValue2))**2) / ((($RmsValue)+($RmsValue2))/2.0) > 2.0 ) print 1; else print 0;}") -eq 1 ]]; then
                echo "Error! The Gaussian_sigma and Inner_sigma do not agree within 200% in \"$RmsStats.txt\"! Please check \"$RmsStats.log\"!"; exit 1
            fi
            # create an rms image from the RmsStats with extension .rms.fits, by replacing the SciImage extension .image.fits
            RmsImage=$(echo "$SciImage" | sed -e 's/\.image\.fits$/.rms/g')
            # create an rms image from the RmsStats with extension .rms.fits, by replacing the SciImage extension .fits
            if [[ "$RmsImage" == *".fits" ]]; then
                RmsImage=$(echo "$SciImage" | sed -e 's/\.fits$/.rms/g')
            fi
            if [[ ! -f "$RmsImage.fits" ]]; then
                echo "# "$(date +'%Y%m%d %Hh%Mm%Ss %Z') > "$RmsImage.log"
                echo "CrabFitsImageArithmetic \"$SciImage\" times 0.0 \"$RmsImage.tmp.fits\"" >> "$RmsImage.log"
                      CrabFitsImageArithmetic  "$SciImage"  times 0.0  "$RmsImage.tmp.fits"   >> "$RmsImage.log"
                echo "CrabFitsImageArithmetic \"$RmsImage.tmp.fits\" adds \"$RmsValue\" \"$RmsImage.fits\"" >> "$RmsImage.log"
                      CrabFitsImageArithmetic  "$RmsImage.tmp.fits"  adds  "$RmsValue"   "$RmsImage.fits"   >> "$RmsImage.log"
                rm "$RmsImage.tmp.fits"
            fi
            if [[ ! -f "$RmsImage.fits" ]]; then
                echo "Error! Failed to run \"CrabFitsImageArithmetic\" to create the RmsImage \"$RmsImage.fits\"! Please check \"$RmsImage.log\"!"; exit 1
            fi
            RmsImage="$RmsImage.fits"
            RmsImages+=("$RmsImage")
        fi
        # 
        # check PbaImage. If not given, then try to find *.pb.fits according to $SciImage fits file name. If nothing found, then generate an empty fits image. 
        if [[ ${#PbaImages[@]} -gt $i ]]; then
            PbaImage="${PbaImages[i]}"
        else
            PbaImage=""
            if [[ "$PbaImage"x == ""x ]]; then PbaImage=$(echo "$SciImage" | sed -e 's/\.image\.fits$/.pb.fits/g');   if [[ "$PbaImage" == "$SciImage" ]] || [[ ! -f "$PbaImage" ]]; then PbaImage=""; fi; fi
            if [[ "$PbaImage"x == ""x ]]; then PbaImage=$(echo "$SciImage" | sed -e 's/\.fits$/.pb.fits/g');          if [[ "$PbaImage" == "$SciImage" ]] || [[ ! -f "$PbaImage" ]]; then PbaImage=""; fi; fi
            if [[ "$PbaImage"x == ""x ]]; then PbaImage=$(echo "$SciImage" | sed -e 's/\.image\.fits$/.flux.fits/g'); if [[ "$PbaImage" == "$SciImage" ]] || [[ ! -f "$PbaImage" ]]; then PbaImage=""; fi; fi
            if [[ "$PbaImage"x == ""x ]]; then PbaImage=$(echo "$SciImage" | sed -e 's/\.fits$/.flux.fits/g');        if [[ "$PbaImage" == "$SciImage" ]] || [[ ! -f "$PbaImage" ]]; then PbaImage=""; fi; fi
            #debug# echo "\$PbaImage = $PbaImage"; sleep 10 #------ bug fixed <20170923> added [[ "$PbaImage" == "$SciImage" ]] condition in the above 4 lines
            if [[ "$PbaImage"x == ""x ]]; then 
                # create a Pba image with extension .pba.fits
                PbaImage=$(echo "$SciImage" | sed -e 's/\.image\.fits$/.pba/g')
                if [[ "$PbaImage" == *".fits" ]]; then
                    PbaImage=$(echo "$SciImage" | sed -e 's/\.sci\.fits$/.pba/g')
                fi
                if [[ "$PbaImage" == *".fits" ]]; then
                    PbaImage=$(echo "$SciImage" | sed -e 's/_sci\.fits$/_pba/g')
                fi
                if [[ "$PbaImage" == *".fits" ]]; then
                    PbaImage=$(echo "$SciImage" | sed -e 's/\.fits$/.pba/g')
                fi
                if [[ ! -f "$PbaImage.fits" ]]; then
                    PbaValue="1.0" #<TODO># fill Pba image with this value. 
                    echo "# "$(date +'%Y%m%d %Hh%Mm%Ss %Z') > "$PbaImage.log"
                    echo "CrabFitsImageArithmetic \"$SciImage\" times 0.0 \"$PbaImage.tmp.fits\"" >> "$PbaImage.log"
                          CrabFitsImageArithmetic  "$SciImage"  times 0.0  "$PbaImage.tmp.fits"   >> "$PbaImage.log"
                    echo "CrabFitsImageArithmetic \"$PbaImage.tmp.fits\" adds \"$PbaValue\" \"$PbaImage.fits\"" >> "$PbaImage.log"
                          CrabFitsImageArithmetic  "$PbaImage.tmp.fits"  adds  "$PbaValue"   "$PbaImage.fits"   >> "$PbaImage.log"
                    rm "$PbaImage.tmp.fits"
                fi
                if [[ ! -f "$PbaImage.fits" ]]; then
                    echo "Error! Failed to run \"CrabFitsImageArithmetic\" to create the PbaImage \"$PbaImage.fits\"! Please check \"$PbaImage.log\"!"; exit 1
                fi
                PbaImage="$PbaImage.fits"
                PbaImages+=("$PbaImage")
            fi
        fi
        # 
        # check SciImage and PsfImage name consistency (only when it is ALMA image)
        if echo "$SciImage" | grep -q "_SB" | grep -q "_GB" | grep -q "_MB" | grep -q "_sci" | grep -q ".spw"; then
            SciImage_check=$(echo "$SciImage" | sed -e 's%\.image\.fits%%g' | sed -e 's%\.fits%%g')   #<TODO># file name
            PsfImage_check=$(echo "$PsfImage" | sed -e 's%\.psf\.fits%%g' | sed -e 's%\.clean-beam\.fits%%g')     #<TODO># file name
            RmsImage_check=$(echo "$RmsImage" | sed -e 's%\.rms\.fits%%g')     #<TODO># file name
            PbaImage_check=$(echo "$PbaImage" | sed -e 's%\.pba\.fits%%g' | sed -e 's%\.pb\.fits%%g' | sed -e 's%\.flux\.fits%%g')     #<TODO># file name
            if [[ "$SciImage_check" != "$PsfImage_check" ]]; then 
                echo ""; echo "Error! The input SciImage \"$SciImage\" and PsfImage \"$PsfImage\" do not match!"; exit 1
            fi
            if [[ "$SciImage_check" != "$RmsImage_check" ]]; then 
                echo ""; echo "Error! The input SciImage \"$SciImage\" and RmsImage \"$RmsImage\" do not match!"; exit 1
            fi
        fi
        # 
        # check PsfImage dimension, make sure the psf has positive sum and has a size of below 300 pixel. 
        PsfImage_fullpath="$PsfImage"
        PsfNAXIS1=$(gethead "$PsfImage_fullpath" NAXIS1)
        PsfNAXIS2=$(gethead "$PsfImage_fullpath" NAXIS2)
        PsfImage_sumpix=$(sumpix "$PsfImage_fullpath")
        if [[ $(awk "BEGIN {if(($PsfNAXIS1>300)||($PsfNAXIS2>300)||($PsfImage_sumpix<0)) print 1; else print 0;}") -eq 1 ]]; then
            PsfImage_cut_rect=$(echo "$PsfImage_fullpath" | sed -e "s/\.fits$/.cut.rect.txt/g")
            if [[ ! -f "$PsfImage_cut_rect" ]]; then
                # cut psf image, make sure the sum is positive, and size below 300 pixel.
                CutBuffer=(100 100)
                #<20170919># if [[ $(awk "BEGIN {if($PsfNAXIS1>300) print 1; else print 0;}") -eq 1 ]]; then CutBuffer[0]=$(awk "BEGIN {print int(($PsfNAXIS1-300)/2.0);}"); fi
                #<20170919># if [[ $(awk "BEGIN {if($PsfNAXIS2>300) print 1; else print 0;}") -eq 1 ]]; then CutBuffer[1]=$(awk "BEGIN {print int(($PsfNAXIS2-300)/2.0);}"); fi
                while [[ $(awk "BEGIN {if(($PsfNAXIS1>2*${CutBuffer[0]})&&($PsfNAXIS2>2*${CutBuffer[1]})) print 1; else print 0;}") -eq 1 ]]; do
                    CutBuffer[0]=$((${CutBuffer[0]}+1))
                    CutBuffer[1]=$((${CutBuffer[1]}+1))
                    CutPos1X=$(awk "BEGIN {print int(($PsfNAXIS1-1.0)/2.0)-(${CutBuffer[0]})}") #<TODO># +1 accounts for the small shift of the ALMA psf fits image produced by Benjamin
                    CutPos1Y=$(awk "BEGIN {print int(($PsfNAXIS2-1.0)/2.0)-(${CutBuffer[1]})}") #<TODO># +1 accounts for the small shift of the ALMA psf fits image produced by Benjamin
                    CutPos2X=$(awk "BEGIN {print int(($PsfNAXIS1-1.0)/2.0)+(${CutBuffer[0]})}") #<TODO># +1 accounts for the small shift of the ALMA psf fits image produced by Benjamin
                    CutPos2Y=$(awk "BEGIN {print int(($PsfNAXIS2-1.0)/2.0)+(${CutBuffer[1]})}") #<TODO># +1 accounts for the small shift of the ALMA psf fits image produced by Benjamin
                    CutImage_fullpath=$(echo "$PsfImage_fullpath" | sed -e "s/\.fits$/.cut_${CutPos1X}_${CutPos1Y}_${CutPos2X}_${CutPos2Y}.fits/g")
                    CutScript_fullpath=$(echo "$PsfImage_fullpath" | sed -e "s/\.fits$/.cut_${CutPos1X}_${CutPos1Y}_${CutPos2X}_${CutPos2Y}.sh/g")
                    CutScriptLog_fullpath=$(echo "$PsfImage_fullpath" | sed -e "s/\.fits$/.cut_${CutPos1X}_${CutPos1Y}_${CutPos2X}_${CutPos2Y}.sh.log/g")
                    echo "#!/bin/bash" > "$CutScript_fullpath"
                    echo "CrabFitsImageCrop \"$PsfImage_fullpath\" -rect $CutPos1X $CutPos1Y $CutPos2X $CutPos2Y -out \"$CutImage_fullpath\"" >> "$CutScript_fullpath"
                    echo "$CutPos1X $CutPos1Y $CutPos2X $CutPos2Y" > "$PsfImage_cut_rect"
                    chmod +x "$CutScript_fullpath"
                    "$CutScript_fullpath" > "$CutScriptLog_fullpath"
                    if [[ ! -f "$CutImage_fullpath" ]]; then
                        echo ""; echo "Error! Failed to run \"$CutScript_fullpath\" and create \"$CutImage_fullpath\"!"
                        echo ""; cat "$CutScriptLog_fullpath"
                        exit 1
                    fi
                    CutImage_sumpix=$(sumpix "$CutImage_fullpath")
                    if [[ "$CutImage_sumpix" != "-"* ]]; then
                        PsfImage_fullpath="$CutImage_fullpath"
                        break
                    else
                        rm "$CutScriptLog_fullpath"
                        rm "$CutScript_fullpath"
                        rm "$CutImage_fullpath"
                        rm "$PsfImage_cut_rect"
                    fi
                done
                CutImage_sumpix=$(sumpix "$CutImage_fullpath")
                if [[ "$CutImage_sumpix" == "-"* ]]; then
                    echo ""; echo "Error! Could not cut the PSF image to make the sum positive! Please check the PSF image \"$PsfImage_fullpath\"!"; exit 1
                fi
            else
                CutRect=($(cat "$PsfImage_cut_rect"))
                CutImage_fullpath=$(echo "$PsfImage_fullpath" | sed -e "s/\.fits$/.cut_${CutRect[0]}_${CutRect[1]}_${CutRect[2]}_${CutRect[3]}.fits/g")
                if [[ ! -f "$CutImage_fullpath" ]]; then 
                    echo ""; echo "Error! Failed to find the cut PSF image \"$CutImage_fullpath\"!"; exit 1
                fi
                PsfImage_fullpath="$CutImage_fullpath"
            fi
        fi
        # 
        # check PsfImage sumpix
        PsfImage_sumpix=$(sumpix "$PsfImage_fullpath")
        if [[ "$PsfImage_sumpix" == "-"* ]]; then
            echo ""; echo "Error! The PSF image \"$PsfImage_fullpath\" has a negative total pixel value!"; exit 1
        fi
        # 
        # check SciImage and RmsImage dimension, make sure they have a size of about 300 pixel (below 450 pixel). 
        if [[ ${#InputBoxSize[@]} -gt 0 ]]; then
            CutSizeM=$(awk "BEGIN {print int(${InputBoxSize[0]}*1.4);}") #<TODO># 450, we only cut images with more than this pixels along any side.
            CutSizeS=${InputBoxSize[0]} #<TODO># 300, we will cut into box with this pixel size if possible
        else
            CutSizeM=450 #<TODO># 450
            CutSizeS=300 #<TODO># 300
        fi
        SciImage_fullpath="$SciImage"
        RmsImage_fullpath="$RmsImage"
        PbaImage_fullpath="$PbaImage"
        SciNAXIS1=$(gethead "$SciImage_fullpath" NAXIS1)
        SciNAXIS2=$(gethead "$SciImage_fullpath" NAXIS2)
        if [[ $(awk "BEGIN {if(($SciNAXIS1>$CutSizeM)||($SciNAXIS2>$CutSizeM)) print 1; else print 0;}") -eq 1 ]]; then
            SciImage_cut_rect=$(echo "$SciImage_fullpath" | sed -e "s/\.fits$/.cut.rect.txt/g")
            RmsImage_cut_rect=$(echo "$RmsImage_fullpath" | sed -e "s/\.fits$/.cut.rect.txt/g")
            PbaImage_cut_rect=$(echo "$PbaImage_fullpath" | sed -e "s/\.fits$/.cut.rect.txt/g")
            if [[ ! -f "$SciImage_cut_rect" ]] || [[ ! -f "$RmsImage_cut_rect" ]] || [[ ! -f "$PbaImage_cut_rect" ]]; then
                CutNumbX=$(awk "BEGIN {print int(($SciNAXIS1)/$CutSizeS/2.0)*2+1}") # cut into odd number of slices along X
                CutNumbY=$(awk "BEGIN {print int(($SciNAXIS2)/$CutSizeS/2.0)*2+1}") # cut into odd number of slices along Y
                if [[ $(awk "BEGIN {if($CutNumbX<3) print 1; else print 0;}") -eq 1 ]]; then
                    CutNumbX=3 # cut into at least ~3 slices along X
                fi
                if [[ $(awk "BEGIN {if($CutNumbY<3) print 1; else print 0;}") -eq 1 ]]; then
                    CutNumbY=3 # cut into at least ~3 slices along Y
                fi
                CutSizeX=$(awk "BEGIN {print int(($SciNAXIS1)/$CutNumbX)}") # ~301
                CutSizeY=$(awk "BEGIN {print int(($SciNAXIS2)/$CutNumbY)}") # ~301
                CutBuffer=$UserCutBuffer # add a buffer region, with about 20 pixels
                for (( icut_y=0; icut_y<$CutNumbY; icut_y++ )); do
                    for (( icut_x=0; icut_x<$CutNumbX; icut_x++ )); do
                        # define cut x1,y1 x2,y2
                        CutPos1X=$(awk "BEGIN {print ($CutSizeX)*($icut_x)-($CutBuffer)}")
                        CutPos1Y=$(awk "BEGIN {print ($CutSizeY)*($icut_y)-($CutBuffer)}")
                        CutPos2X=$(awk "BEGIN {print ($CutSizeX)*($icut_x+1)+($CutBuffer)}")
                        CutPos2Y=$(awk "BEGIN {print ($CutSizeY)*($icut_y+1)+($CutBuffer)}")
                        
                        # cut SciImage
                        CutImage_fullpath=$(echo "$SciImage_fullpath" | sed -e "s/\.fits$/.cut_${CutPos1X}_${CutPos1Y}_${CutPos2X}_${CutPos2Y}.fits/g")
                        CutScript_fullpath=$(echo "$SciImage_fullpath" | sed -e "s/\.fits$/.cut_${CutPos1X}_${CutPos1Y}_${CutPos2X}_${CutPos2Y}.sh/g")
                        CutScriptLog_fullpath=$(echo "$SciImage_fullpath" | sed -e "s/\.fits$/.cut_${CutPos1X}_${CutPos1Y}_${CutPos2X}_${CutPos2Y}.sh.log/g")
                        echo "#!/bin/bash" > "$CutScript_fullpath"
                        echo "CrabFitsImageCrop \"$SciImage_fullpath\" -rect $CutPos1X $CutPos1Y $CutPos2X $CutPos2Y -out \"$CutImage_fullpath\"" >> "$CutScript_fullpath"
                        echo "$CutPos1X $CutPos1Y $CutPos2X $CutPos2Y" >> "$SciImage_cut_rect"
                        chmod +x "$CutScript_fullpath"
                        "$CutScript_fullpath" > "$CutScriptLog_fullpath"
                        if [[ ! -f "$CutImage_fullpath" ]]; then
                            echo ""; echo "Error! Failed to run \"$CutScript_fullpath\" and create \"$CutImage_fullpath\"!"
                            echo ""; cat "$CutScriptLog_fullpath"
                            exit 1
                        fi
                        # write to OutputDir/List_of_Input_*_Images.txt
                        echo "$CutImage_fullpath" >> "$OutputDir/List_of_Input_Sci_Images.txt"
                        
                        # cut RmsImage
                        CutImage_fullpath=$(echo "$RmsImage_fullpath" | sed -e "s/\.fits$/.cut_${CutPos1X}_${CutPos1Y}_${CutPos2X}_${CutPos2Y}.fits/g")
                        CutScript_fullpath=$(echo "$RmsImage_fullpath" | sed -e "s/\.fits$/.cut_${CutPos1X}_${CutPos1Y}_${CutPos2X}_${CutPos2Y}.sh/g")
                        CutScriptLog_fullpath=$(echo "$RmsImage_fullpath" | sed -e "s/\.fits$/.cut_${CutPos1X}_${CutPos1Y}_${CutPos2X}_${CutPos2Y}.sh.log/g")
                        echo "#!/bin/bash" > "$CutScript_fullpath"
                        echo "CrabFitsImageCrop \"$RmsImage_fullpath\" -rect $CutPos1X $CutPos1Y $CutPos2X $CutPos2Y -out \"$CutImage_fullpath\"" >> "$CutScript_fullpath"
                        echo "$CutPos1X $CutPos1Y $CutPos2X $CutPos2Y" >> "$RmsImage_cut_rect"
                        chmod +x "$CutScript_fullpath"
                        "$CutScript_fullpath" > "$CutScriptLog_fullpath"
                        if [[ ! -f "$CutImage_fullpath" ]]; then
                            echo ""; echo "Error! Failed to run \"$CutScript_fullpath\" and create \"$CutImage_fullpath\"!"
                            echo ""; cat "$CutScriptLog_fullpath"
                            exit 1
                        fi
                        # write to OutputDir/List_of_Input_*_Images.txt
                        echo "$CutImage_fullpath" >> "$OutputDir/List_of_Input_Rms_Images.txt"
                        
                        # cut PbaImage
                        CutImage_fullpath=$(echo "$PbaImage_fullpath" | sed -e "s/\.fits$/.cut_${CutPos1X}_${CutPos1Y}_${CutPos2X}_${CutPos2Y}.fits/g")
                        CutScript_fullpath=$(echo "$PbaImage_fullpath" | sed -e "s/\.fits$/.cut_${CutPos1X}_${CutPos1Y}_${CutPos2X}_${CutPos2Y}.sh/g")
                        CutScriptLog_fullpath=$(echo "$PbaImage_fullpath" | sed -e "s/\.fits$/.cut_${CutPos1X}_${CutPos1Y}_${CutPos2X}_${CutPos2Y}.sh.log/g")
                        echo "#!/bin/bash" > "$CutScript_fullpath"
                        echo "CrabFitsImageCrop \"$PbaImage_fullpath\" -rect $CutPos1X $CutPos1Y $CutPos2X $CutPos2Y -out \"$CutImage_fullpath\"" >> "$CutScript_fullpath"
                        echo "$CutPos1X $CutPos1Y $CutPos2X $CutPos2Y" >> "$PbaImage_cut_rect"
                        chmod +x "$CutScript_fullpath"
                        "$CutScript_fullpath" > "$CutScriptLog_fullpath"
                        if [[ ! -f "$CutImage_fullpath" ]]; then
                            echo ""; echo "Error! Failed to run \"$CutScript_fullpath\" and create \"$CutImage_fullpath\"!"
                            echo ""; cat "$CutScriptLog_fullpath"
                            exit 1
                        fi
                        # write to OutputDir/List_of_Input_*_Images.txt
                        echo "$CutImage_fullpath" >> "$OutputDir/List_of_Input_Pba_Images.txt"
                        
                        # for Psf image, 
                        # write to OutputDir/List_of_Input_*_Images.txt
                        echo "$PsfImage_fullpath" >> "$OutputDir/List_of_Input_Psf_Images.txt"
                    done
                done
            else
                # if we found "$SciImage_cut_rect", then we read the cut rect rather than redo the cut rect computation. 
                IFS=$'\n' CutRect_list=($(<"$SciImage_cut_rect"))
                for (( icut=0; icut<${#CutRect_list[@]}; icut++ )); do
                    IFS=' ' CutRect=( $(echo ${CutRect_list[$icut]}) )
                    
                    # check CutImage_fullpath for SciImage
                    CutImage_fullpath=$(echo "$SciImage_fullpath" | sed -e "s/\.fits$/.cut_${CutRect[0]}_${CutRect[1]}_${CutRect[2]}_${CutRect[3]}.fits/g")
                    if [[ ! -f "$CutImage_fullpath" ]]; then 
                        echo ""; echo "Error! Failed to find the cut SCI image \"$CutImage_fullpath\"!"; exit 1
                    fi
                    # write to OutputDir/List_of_Input_*_Images.txt
                    echo "$CutImage_fullpath" >> "$OutputDir/List_of_Input_Sci_Images.txt"
                    
                    # check CutImage_fullpath for RmsImage
                    CutImage_fullpath=$(echo "$RmsImage_fullpath" | sed -e "s/\.fits$/.cut_${CutRect[0]}_${CutRect[1]}_${CutRect[2]}_${CutRect[3]}.fits/g")
                    if [[ ! -f "$CutImage_fullpath" ]]; then 
                        echo ""; echo "Error! Failed to find the cut RMS image \"$CutImage_fullpath\"!"; exit 1
                    fi
                    # write to OutputDir/List_of_Input_*_Images.txt
                    echo "$CutImage_fullpath" >> "$OutputDir/List_of_Input_Rms_Images.txt"
                    
                    # check CutImage_fullpath for PbaImage
                    CutImage_fullpath=$(echo "$PbaImage_fullpath" | sed -e "s/\.fits$/.cut_${CutRect[0]}_${CutRect[1]}_${CutRect[2]}_${CutRect[3]}.fits/g")
                    if [[ ! -f "$CutImage_fullpath" ]]; then 
                        echo ""; echo "Error! Failed to find the cut PBA image \"$CutImage_fullpath\"!"; exit 1
                    fi
                    # write to OutputDir/List_of_Input_*_Images.txt
                    echo "$CutImage_fullpath" >> "$OutputDir/List_of_Input_Pba_Images.txt"
                    
                    # for Psf image, 
                    # write to OutputDir/List_of_Input_*_Images.txt
                    echo "$PsfImage_fullpath" >> "$OutputDir/List_of_Input_Psf_Images.txt"
                done
            fi
            #break
        else
            echo "$SciImage_fullpath" >> "$OutputDir/List_of_Input_Sci_Images.txt"
            echo "$RmsImage_fullpath" >> "$OutputDir/List_of_Input_Rms_Images.txt"
            echo "$PbaImage_fullpath" >> "$OutputDir/List_of_Input_Pba_Images.txt"
            echo "$PsfImage_fullpath" >> "$OutputDir/List_of_Input_Psf_Images.txt"
        fi
    done
fi
# 
# Load InputCats, SciImages and PsfImages from Output/List_of_Input_*.txt
IFS=$'\n' InputCats=($(<"$OutputDir/List_of_Input_Catalog.txt"))
IFS=$'\n' SciImages=($(<"$OutputDir/List_of_Input_Sci_Images.txt"))
IFS=$'\n' PsfImages=($(<"$OutputDir/List_of_Input_Psf_Images.txt"))
IFS=$'\n' RmsImages=($(<"$OutputDir/List_of_Input_Rms_Images.txt"))
IFS=$'\n' PbaImages=($(<"$OutputDir/List_of_Input_Pba_Images.txt"))
if [[ ${#SciImages[@]} -eq 0 || ${#PsfImages[@]} -eq 0 ]]; then
    echo "Error! Failed to read \"$OutputDir/List_of_Input_Sci_Images.txt\" and \"$OutputDir/List_of_Input_Psf_Images.txt\"!"
    exit 1
fi
if [[ ${#SciImages[@]} -eq 0 || ${#RmsImages[@]} -eq 0 ]]; then
    echo "Error! Failed to read \"$OutputDir/List_of_Input_Sci_Images.txt\" and \"$OutputDir/List_of_Input_Rms_Images.txt\"!"
    exit 1
fi
if [[ ${#SciImages[@]} -eq 0 || ${#PbaImages[@]} -eq 0 ]]; then
    echo "Error! Failed to read \"$OutputDir/List_of_Input_Sci_Images.txt\" and \"$OutputDir/List_of_Input_Pba_Images.txt\"!"
    exit 1
fi
#echo ${SciImages[0]}
#echo ${PsfImages[0]}
#echo ${RmsImages[0]}
#echo ${PbaImages[0]}
#exit

















# 
# fit ALMA calibrated images
# 

echo "Running astrodepth_prior_extraction_photometry ..."
#astrodepth_prior_extraction_photometry -cat "$InputCat" -sci "${SciImages[0]}" -psf "${PsfImages[0]}"
#astrodepth_prior_extraction_photometry -cat "$InputCat" -sci "${SciImages[@]}" -psf "${PsfImages[@]}"

for (( i=0; i<${#SciImages[@]}; i++ )); do
    # 
    # Control Start End
    if [[ x"$UserFitStart" != x ]]; then
        if [[ $(($i+1)) -lt $UserFitStart ]]; then 
            continue
        fi
    fi
    if [[ x"$UserFitEnd" != x ]]; then
        if [[ $(($i+1)) -gt $UserFitEnd ]]; then 
            continue
        fi
    fi
    # 
    # Get SourceName
    SciImage="${SciImages[i]}"
    PsfImage="${PsfImages[i]}"
    RmsImage="${RmsImages[i]}"
    PbaImage="${PbaImages[i]}"
    SourceDir="$OutputSubDir"
    SourceName=$(basename "$SciImage" | sed -e 's%\.fits%%g')   #<TODO># file name
    # 
    # cd OutputDir
    CurrentDir=$(pwd)
    cd "$OutputDir/"
      OutputDir_fullpath=$(pwd)
    # 
    # print
    echo ""
    echo ""
    echo "************"
    echo "SourceName = $SourceName   ($(($i+1))/${#SciImages[@]})   ($(date +'%Y%m%d %Hh%Mm%Ss %Z'))"
    echo "SciImage = \"$SciImage\""
    echo "PsfImage = \"$PsfImage\""
    echo "RmsImage = \"$RmsImage\""
    echo "PbaImage = \"$PbaImage\""
    echo "OutputDir = \"$OutputDir_fullpath/$SourceDir/$SourceName\""
    echo "***********"
    echo "Running astrodepth_prior_extraction_photometry"
    echo  "#!/bin/bash"                                                                                             >  "$SourceDir/$SourceName.run.bash"
    echo  "# "                                                                                                      >> "$SourceDir/$SourceName.run.bash"
    echo  "source $ALMACOSMOS_SETUP_SCRIPT"                                                                           >> "$SourceDir/$SourceName.run.bash"
    echo  "cd \"$OutputDir_fullpath/\""                                                                             >> "$SourceDir/$SourceName.run.bash"
    # 
    #<20170612> fix pb_corr array mask problem
    #<20170626> fix cat_index fit_X.param Note problem
    #echo  "cd \"$SourceDir/$SourceName/\""                                                                                                      >> "$SourceDir/$SourceName.run.bash"
    ##echo  "if [[ ! -f astrodepth_go_galfit.sm.backup.20170611 ]]; then cp astrodepth_go_galfit.sm astrodepth_go_galfit.sm.backup.20170611; fi" >> "$SourceDir/$SourceName.run.bash"
    #echo  "if [[ ! -f astrodepth_go_galfit.sm.backup.20170626 ]]; then cp astrodepth_go_galfit.sm astrodepth_go_galfit.sm.backup.20170626; fi" >> "$SourceDir/$SourceName.run.bash"
    #echo  "cp ~/Cloud/Github/DeepFields.SuperDeblending/Softwares/astrodepth_prior_extraction_photometry_go_galfit.sm astrodepth_go_galfit.sm" >> "$SourceDir/$SourceName.run.bash"
    #echo  "echo \"macro read astrodepth_go_galfit.sm print_result_fit_2\" | smdl"                                                                >> "$SourceDir/$SourceName.run.bash"
    #echo  "cd ../../"                                                                                                                          >> "$SourceDir/$SourceName.run.bash"
    #
    # determine buffer if the image is cut
    if echo "$SciImage" | grep -q ".*\.cut_[0-9+-]*_[0-9+-]*_[0-9+-]*_[0-9+-]*\.fits$"; then
        CutBuffer=$UserCutBuffer
    else
        CutBuffer=0
    fi
    # 
    echo  "astrodepth_prior_extraction_photometry \\"                                                               >> "$SourceDir/$SourceName.run.bash"
    echo  "                                       -cat "$(printf "'%s' " "${InputCats[@]}")" \\"                    >> "$SourceDir/$SourceName.run.bash"
    echo  "                                       -sci \"$SciImage\" \\"                                            >> "$SourceDir/$SourceName.run.bash"
    echo  "                                       -psf \"$PsfImage\" \\"                                            >> "$SourceDir/$SourceName.run.bash"
    echo  "                                       -rms \"$RmsImage\" \\"                                            >> "$SourceDir/$SourceName.run.bash"
    echo  "                                       -pba \"$PbaImage\" \\"                                            >> "$SourceDir/$SourceName.run.bash"
    echo  "                                       -buffer $CutBuffer \\"                                            >> "$SourceDir/$SourceName.run.bash"
    echo  "                                       -output-dir \"$SourceDir\" \\"                                    >> "$SourceDir/$SourceName.run.bash"
    echo  "                                       -output-name \"$SourceName\" \\"                                  >> "$SourceDir/$SourceName.run.bash"
    if [[ $UserFitWithGalfit30 -gt 0 ]]; then
    echo  "                                       -galfit30 \\"                                                     >> "$SourceDir/$SourceName.run.bash"
    elif [[ $UserFitWithGalfit30 -lt 0 ]]; then
    echo  "                                       -no-galfit30 \\"                                                  >> "$SourceDir/$SourceName.run.bash"
    fi
    if [[ $UserFitWithGalfit255 -gt 0 ]]; then
    echo  "                                       -galfit255 \\"                                                    >> "$SourceDir/$SourceName.run.bash"
    elif [[ $UserFitWithGalfit255 -lt 0 ]]; then
    echo  "                                       -no-galfit255 \\"                                                 >> "$SourceDir/$SourceName.run.bash"
    fi
    if [[ $UserFitSkyBackground -gt 0 ]]; then
    echo  "                                       -fit-sky \\"                                                      >> "$SourceDir/$SourceName.run.bash"
    elif [[ $UserFitSkyBackground -lt 0 ]]; then
    echo  "                                       -do-not-fit-sky \\"                                               >> "$SourceDir/$SourceName.run.bash"
    fi
    if [[ ${#InputGalfitPriorPeakSNR[@]} -gt 0 ]]; then
    echo  "                                       -galfit-prior-peak-snr ${InputGalfitPriorPeakSNR} \\"             >> "$SourceDir/$SourceName.run.bash"
    fi
    if [[ ${#InputGalfitPriorTotalSNR[@]} -gt 0 ]]; then
    echo  "                                       -galfit-prior-total-snr ${InputGalfitPriorTotalSNR} \\"           >> "$SourceDir/$SourceName.run.bash"
    fi
    if [[ ${#InputGalfitVaryMagErr[@]} -gt 0 ]]; then
    echo  "                                       -galfit-prior-vary-position-threshold-magerr ${InputGalfitVaryMagErr} \\" >> "$SourceDir/$SourceName.run.bash"
    fi
    if [[ ${#InputGalfitVaryTotRMS[@]} -gt 0 ]]; then
    echo  "                                       -galfit-prior-vary-position-threshold-totrms ${InputGalfitVaryTotRMS} \\" >> "$SourceDir/$SourceName.run.bash"
    fi
    if [[ ${#InputGalfitVaryMaxArcsec[@]} -gt 0 ]]; then
    echo  "                                       -galfit-prior-vary-position-maximum-arcsec ${InputGalfitVaryMaxArcsec} \\" >> "$SourceDir/$SourceName.run.bash"
    fi
    if [[ ${#InputGalfitFitGaussianMagErr[@]} -gt 0 ]]; then
    echo  "                                       -galfit-prior-fit-gaussian-threshold-magerr ${InputGalfitFitGaussianMagErr} \\" >> "$SourceDir/$SourceName.run.bash"
    fi
    if [[ ${#InputGalfitFitGaussianTotRMS[@]} -gt 0 ]]; then
    echo  "                                       -galfit-prior-fit-gaussian-threshold-totrms ${InputGalfitFitGaussianTotRMS} \\" >> "$SourceDir/$SourceName.run.bash"
    fi
    if [[ ${#InputGalfitFitSersicMagErr[@]} -gt 0 ]]; then
    echo  "                                       -galfit-prior-fit-sersic-threshold-magerr ${InputGalfitFitSersicMagErr} \\" >> "$SourceDir/$SourceName.run.bash"
    fi
    if [[ ${#InputGalfitFitSersicTotRMS[@]} -gt 0 ]]; then
    echo  "                                       -galfit-prior-fit-sersic-threshold-totrms ${InputGalfitFitSersicTotRMS} \\" >> "$SourceDir/$SourceName.run.bash"
    fi
    echo  "                                       -steps getpix galfit gaussian sersic ${UserSteps[@]} final \\"    >> "$SourceDir/$SourceName.run.bash"
    echo  "                                       -unlock ${UserUnlock[@]} \\"                                      >> "$SourceDir/$SourceName.run.bash"
    echo  "                                       -overwrite ${UserOverwrite[@]}"                                   >> "$SourceDir/$SourceName.run.bash"
    echo  ""                                                                                                        >> "$SourceDir/$SourceName.run.bash"
    # 
    #<20170612># check image with problematic "image_sci_pixnoise.txt"
    ##if [[ "$SourceName" == "2011.0.00097.S_SB1_GB1_MB2_COSMOS8_field9_sci"* || \
    ##      "$SourceName" == "2012.1.00523.S_SB9_GB1_MB1_hz1_sci"* || \
    ##      "$SourceName" == "2013.1.00034.S_SB1_GB2_MB1_midz_cell3_277716_sci"* || \
    ##      "$SourceName" == "2013.1.00034.S_SB1_GB3_MB1_midz_cell4_170263_sci"* || \
    ##      "$SourceName" == "2013.1.00034.S_SB1_GB3_MB1_midz_cell9_116351_sci"* || \
    ##      "$SourceName" == "2013.1.00034.S_SB3_GB1_MB1_highz_cell7_58334_sci"* || \
    ##      "$SourceName" == "2013.1.00034.S_SB3_GB2_MB1_highz_cell8_189852_sci"* || \
    ##      "$SourceName" == "2013.1.00034.S_SB3_GB3_MB1_highz_cell7_219362_sci"* || \
    ##      "$SourceName" == "2013.1.00118.S_SB1_GB1_MB1_AzTECC29_sci"* || \
    ##      "$SourceName" == "2013.1.00151.S_SB1_GB1_MB1__511043167__sci"* || \
    ##      "$SourceName" == "2013.1.00884.S_SB1_GB1_MB1_CS_AGN2_sci"* || \
    ##      "$SourceName" == "2015.1.00137.S_SB3_GB1_MB1_z12_73_sci"* || \
    ##      "$SourceName" == "2015.1.00137.S_SB3_GB1_MB1_z12_85_sci"* || \
    ##      "$SourceName" == "2015.1.00137.S_SB4_GB1_MB1_z12_137_sci"* || \
    ##      "$SourceName" == "2015.1.00379.S_SB2_GB1_MB1_VUDS0511234877_sci"* || \
    ##      "$SourceName" == "2015.1.00861.S_SB1_GB1_MB1_PACS_787_sci"* ]]; then
    ####echo  "cd \"$SourceDir/$SourceName/\""                                                                        >> "$SourceDir/$SourceName.run.bash"
    ####echo  "echo \"macro read astrodepth_go_getpix.sm print_result\" | smdl"                                         >> "$SourceDir/$SourceName.run.bash"
    ####echo  "echo \"macro read astrodepth_go_galfit.sm print_result_fit_2\" | smdl"                                   >> "$SourceDir/$SourceName.run.bash"
    ####echo  "echo \"macro read astrodepth_go_galfit.sm print_result_final\" | smdl"                                   >> "$SourceDir/$SourceName.run.bash"
    ####echo  "cd ../../"                                                                                             >> "$SourceDir/$SourceName.run.bash"
    ##echo  "astrodepth_prior_extraction_photometry -cat \"$InputCat\" \\"                                            >> "$SourceDir/$SourceName.run.bash"
    ##echo  "                                       -sci \"$SciImage\" \\"                                            >> "$SourceDir/$SourceName.run.bash"
    ##echo  "                                       -psf \"$PsfImage\" \\"                                            >> "$SourceDir/$SourceName.run.bash"
    ##echo  "                                       -output-name \"$SourceName\" \\"                                  >> "$SourceDir/$SourceName.run.bash"
    ##echo  "                                       -steps \"getpix\" \"galfit\" \"gaussian\" \"final\" \\"           >> "$SourceDir/$SourceName.run.bash"
    ##echo  "                                       -overwrite getpix galfit gaussian final"                          >> "$SourceDir/$SourceName.run.bash"
    ##echo  ""                                                                                                        >> "$SourceDir/$SourceName.run.bash"
    ##fi
    # 
    #<20170613># check whether "fit_2.log" contains "nan"
    ##if grep -i -w -q "nan" "$SourceDir/$SourceName/fit_2.log"; then
    ###if [[ "$SourceName" == "2011.0.00064.S_SB1_GB1_MB1_AzTEC-3_sci.spw0_1_2_3.cont.I.image"* ]]; then
    ##echo  "astrodepth_prior_extraction_photometry -cat \"$InputCat\" \\"                                            >> "$SourceDir/$SourceName.run.bash"
    ##echo  "                                       -sci \"$SciImage\" \\"                                            >> "$SourceDir/$SourceName.run.bash"
    ##echo  "                                       -psf \"$PsfImage\" \\"                                            >> "$SourceDir/$SourceName.run.bash"
    ##echo  "                                       -output-name \"$SourceName\" \\"                                  >> "$SourceDir/$SourceName.run.bash"
    ##echo  "                                       -steps getpix galfit gaussian final \\"                           >> "$SourceDir/$SourceName.run.bash"
    ##echo  "                                       -overwrite getpix galfit gaussian final"                          >> "$SourceDir/$SourceName.run.bash"
    ##fi
    # 
    #<20170613> fix "getpix.result" (pb_corr), "fit_2.result" (pb_corr and getpix.mask), "fit_2.log" (nan)
    ##echo  "cd \"$SourceDir/$SourceName/\""                                                                          >> "$SourceDir/$SourceName.run.bash"
    ##echo  "echo \"macro read astrodepth_go_galfit.sm print_result_fit_2\" | smdl"                                     >> "$SourceDir/$SourceName.run.bash"
    ##echo  "cd ../../"                                                                                               >> "$SourceDir/$SourceName.run.bash"
    echo  ""                                                                                 >> "$SourceDir/$SourceName.run.bash"
    echo  "# do cleaning"                                                                    >> "$SourceDir/$SourceName.run.bash"
    echo  "if [[ -d \"$SourceDir/$SourceName/\" ]]; then"                                    >> "$SourceDir/$SourceName.run.bash"
    echo  "   cd \"$SourceDir/$SourceName/\""                                                >> "$SourceDir/$SourceName.run.bash"
    echo  "   rm galfit.* aaa_* aaa.* *.sky2xy.* *.tmp *.backup 2>/dev/null"                 >> "$SourceDir/$SourceName.run.bash"
    if [[ $UserClean -ge 1 ]]; then
    echo  "   rm prior_id.txt prior_x_y.txt 2>/dev/null"                                     >> "$SourceDir/$SourceName.run.bash"
    echo  "   rm *.log *.sm .smhist getpix.radius.* fit_0.* fit_1.* image_*.fits 2>/dev/null" >> "$SourceDir/$SourceName.run.bash"
    echo  "   rm ../*.txt ../*.sm ../.smhist 2>/dev/null"                                    >> "$SourceDir/$SourceName.run.bash"
    fi
    echo  "fi"                                                                               >> "$SourceDir/$SourceName.run.bash"
    echo  ""                                                                                 >> "$SourceDir/$SourceName.run.bash"
    echo  ""                                                                                 >> "$SourceDir/$SourceName.run.bash"
    # 
    chmod +x "$SourceDir/$SourceName.run.bash"
    ./$SourceDir/$SourceName.run.bash
    #rm "$SourceDir/astrodepth_image_0_catalog_0_sky2xy.txt" 2>/dev/null
    #rm "$SourceDir/astrodepth_image_0_catalog_0_x_y.txt"    2>/dev/null
    cd "$CurrentDir"
    #break
done



echo "All Done!"










