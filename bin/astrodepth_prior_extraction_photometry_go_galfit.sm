read_data 00
    load astroGalfit.sm
    data "prior_x_y.txt" read {_px 1.f _py 2.f}
    set _id = 0,dimen(_px)-1 # this is the catalog index from 0 to dimen(catalog)-1, not catalog object id itself
    set _se = (_px>0 && _py>0)
    if(sum(_se) > 0) {
        set id = _id if(_se) # this is the catalog index from 0 to dimen(catalog)-1, not catalog object id itself
        set px = _px if(_se)
        set py = _py if(_se)
        if(is_file("No_catalog_source_within_image")) {!rm "No_catalog_source_within_image"}
    } else {
        print "No_catalog_source_within_image" 'No catalog source within image.\n' {}
        exit
    }


read_pixscale 00
    if(is_file("image_sci_pixscale.txt")) {
        if(is_vector(pixscale)) {unset pixscale}
        data "image_sci_pixscale.txt" read {pixscale 1}
        if(!is_vector(pixscale)) {!rm "image_sci_pixscale.txt"} # added a check here
    }
    if(!is_file("image_sci_pixscale.txt")) {
        !pixscale "image_sci.fits" > "image_sci_pixscale.txt"
    }
    if(!is_file("image_sci_pixscale.txt")) {
        echo "Error! Failed to get pixscale from the image_sci.fits! Failed to read image_sci_pixscale.txt! Exit!"
        exit
    }
    data "image_sci_pixscale.txt" read {pixscale 1}


read_pixnoise 00
    if(is_file("image_sci_pixnoise.txt")) {
        if(is_vector(pixnoise)) {unset pixnoise}
        data "image_sci_pixnoise.txt" read {pixnoise 1}
        if(!is_vector(pixnoise)) {!rm "image_sci_pixnoise.txt"} else {return} # added a check here
    }
    if(!is_file("image_sci_pixnoise.txt")) {
        !CrabPhotImageStatistics "image_sci.fits" > "image_sci_pixstats.txt"
        data "image_sci_pixstats.txt" read {pixstats 7}
        define print_noheader 1
        print "image_sci_pixnoise.txt" '%g\n' {pixstats}
        define print_noheader 0
    }
    if(!is_file("image_sci_pixnoise.txt")) {
        echo "Error! Failed to get pixnoise from the image_sci.fits! Failed to read image_sci_pixnoise.txt! Exit!"
        exit
    }
    data "image_sci_pixnoise.txt" read {pixnoise 1}


calc_beamarea 00
    if(is_vector(beamarea)) {unset beamarea}
    if(is_vector(beam_maj)) {unset beam_maj}
    if(is_vector(beam_min)) {unset beam_min}
    if(is_vector(beam_pa))  {unset beam_pa}
    if(is_file("image_sci_beamarea.txt") && is_file("image_sci_beamsize.txt")) {
        #!mv "image_sci_beamarea.txt" "image_sci_beamarea.txt.backup"
        data "image_sci_beamarea.txt" read {beamarea 1.f}
        data "image_sci_beamsize.txt" read {beam_maj 1.f beam_min 2.f beam_pa 3.f}
        if(!is_vector(beamarea) || !is_vector(beam_maj) || !is_vector(beam_min) || !is_vector(beam_pa)) {
            !rm image_sci_beamarea.* 2>/dev/null
            !rm image_sci_beamarea_sinc.* 2>/dev/null
        } else {
            if(beamarea<=0) {
                !rm image_sci_beamarea.* 2>/dev/null
                !rm image_sci_beamarea_sinc.* 2>/dev/null
            }
        } # added a check here
    }
    if(!is_file("image_sci_beamarea.txt")) {
        if(is_vector(beamarea)) {unset beamarea}
        if(is_file("image_sci.fits")) {
            !gethead "image_sci.fits" "BMAJ" "BMIN" "BPA" > "image_sci_beamsize.tmp"
            if(is_vector(beam_maj)) {unset beam_maj}
            if(is_vector(beam_min)) {unset beam_min}
            if(is_vector(beam_pa))  {unset beam_pa}
            data "image_sci_beamsize.tmp" read {beam_maj 1 beam_min 2 beam_pa 3}
            if(is_vector(beam_maj) && is_vector(beam_min) && is_vector(beam_pa)) {
                set beam_maj = beam_maj * 3600.0 # arcsec
                set beam_min = beam_min * 3600.0 # arcsec
                print "image_sci_beamsize.txt" '%18.10f %18.10f %18.10f\n'{beam_maj beam_min beam_pa}
                set beamarea = pi/(4.0*ln(2)) * (beam_maj * beam_min) # arcsec-square
                set beamarea_sinc = pi * (beam_maj/1.89549 * beam_min/1.89549) # arcsec-square
                set beamarea_circle = pi/4.0 * (beam_maj * beam_min) # arcsec-square
                define print_noheader 1
                print "image_sci_beamarea.txt" '%g\n' {beamarea}
                print "image_sci_beamarea_sinc.txt" '%g\n' {beamarea_sinc}
                print "image_sci_beamarea_circle.txt" '%g\n' {beamarea_circle}
                define print_noheader 0
            } else {
                print 'Warning! Failed to gethead "image_sci.fits" "BMAJ" "BMIN" "BPA"! Try next method to estimate beam_maj, beam_min, beam_pa and beamarea!\n' {}
            }
            !rm "image_sci_beamsize.tmp"
        }
    }
    if(!is_file("image_sci_beamarea.txt")) {
        if(is_vector(beamarea)) {unset beamarea}
        if(is_file("image_psf.fits")) {
            !gethead "image_psf.fits" "BMAJ" "BMIN" "BPA" > "image_psf_beamsize.tmp"
            if(is_vector(beam_maj)) {unset beam_maj}
            if(is_vector(beam_min)) {unset beam_min}
            if(is_vector(beam_pa))  {unset beam_pa}
            data "image_psf_beamsize.tmp" read {beam_maj 1 beam_min 2 beam_pa 3}
            if(is_vector(beam_maj) && is_vector(beam_min) && is_vector(beam_pa)) {
                set beamarea = pi/(4.0*ln(2)) * (beam_maj*3600.0 * beam_min*3600.0) # arcsec-square
                set beamarea_sinc = pi * (beam_maj/1.89549*3600.0 * beam_min/1.89549*3600.0) # arcsec-square
                set beamarea_circle = pi/4.0 * (beam_maj*3600.0 * beam_min*3600.0) # arcsec-square
                print "image_psf_beamsize.txt" '%18.10f %18.10f %18.10f\n'{beam_maj beam_min beam_pa}
                define print_noheader 1
                print "image_psf_beamarea.txt" '%g\n' {beamarea}
                print "image_psf_beamarea_sinc.txt" '%g\n' {beamarea_sinc}
                print "image_psf_beamarea_circle.txt" '%g\n' {beamarea_circle}
                define print_noheader 0
                !cp "image_psf_beamsize.txt" "image_sci_beamarea.txt"
            } else {
                print 'Warning! Failed to gethead "image_psf.fits" "BMAJ" "BMIN" "BPA"! Try next method to estimate beam_maj, beam_min, beam_pa and beamarea!\n' {}
            }
            !rm "image_psf_beamsize.tmp"
        }
    }
    if(!is_file("image_sci_beamarea.txt")) {
        if(is_vector(beamarea)) {unset beamarea}
        if(is_file("image_psf.fits")) {
            # measure at which radius an aperture has half of the total flux in image_psf.fits
            #!CrabPhotImageStatistics image_psf.fits > image_psf.fits.statistics.txt
            #data image_psf.fits.statistics.txt read {image_psf_f_peak 5 image_psf_f_total 6}
            !gethead "image_psf.fits" "NAXIS1" "NAXIS2" > "image_psf.fits.gethead.naxis.txt"
            data "image_psf.fits.gethead.naxis.txt" read {image_psf_naxis1 1 image_psf_naxis2 2}
            !rm "image_psf.fits.gethead.naxis.txt"
            !getpix -n 1 "%.15g" "image_psf.fits" 1-$(image_psf_naxis1) 1-$(image_psf_naxis2) > "image_psf.fits.getpix.all.pixels.txt"
            data "image_psf.fits.getpix.all.pixels.txt" read {image_psf_pixel_values 1}
            !rm "image_psf.fits.getpix.all.pixels.txt"
            vecminmax image_psf_pixel_values image_psf_pixel_min image_psf_pixel_max
            if(!is_vector(pixscale)) {read_pixscale}
            set temp_gaussian_fpix = image_psf_pixel_values if(image_psf_pixel_values>=$image_psf_pixel_max*0.0)
            set temp_gaussian_area = sum(temp_gaussian_fpix)
            set temp_gaussian_peak = $image_psf_pixel_max
            set temp_gaussian_sigma = sqrt(temp_gaussian_area / temp_gaussian_peak / (2*pi) / 2.0) # 2D Gaussian Area = 2*pi*a*(sigma_x**2 + sigma_y**2)
            set temp_gaussian_fwhm = 2*sqrt(2*ln(2)) * temp_gaussian_sigma
            #set beamarea = float(sum(image_psf_pixel_values>=$image_psf_pixel_max*0.5))*pixscale*pixscale # arcsec-square
            set beamarea = pi/(4.0*ln(2)) * temp_gaussian_fwhm**2 # arcsec-square
            set beam_maj = temp_gaussian_fwhm
            set beam_min = temp_gaussian_fwhm
            set beam_pa = 0.0
            print "image_sci_beamsize.txt" '%g %g %g\n' {beam_maj beam_min beam_pa}
            define print_noheader 1
            print "image_sci_beamarea.txt" '%g\n' {beamarea}
            print "image_sci_beamarea.warning.txt" 'Warning! No BMAJ BMIN BPA keywords in image_sci.fits or image_psf.fits, estimating beamarea from image_psf.fits assuming Gaussian area and peak relation.\n' {}
            define print_noheader 0
            !cat "image_sci_beamarea.warning.txt"
            #
            #define print_noheader 1
            #print "image_sci_beamarea.txt" '%g\n' {beamarea}
            #print "image_sci_beamarea.warning.txt" 'Warning! No BMAJ BMIN BPA keywords in image_sci.fits or image_psf.fits, taking half maximum pixel count.\n' {}
            #define print_noheader 0
            #<20170923># set beamarea = 1.0
            #<20170923># define print_noheader 1
            #<20170923># print "image_sci_beamarea.txt" '%g\n' {beamarea}
            #<20170923># print "image_sci_beamarea.warning.txt" 'Warning! No BMAJ BMIN BPA keywords in image_sci.fits or image_psf.fits, setting beamarea to 1.0.\n' {}
            #<20170923># define print_noheader 0
        }
    }
    if(!is_vector(beamarea) || !is_vector(beam_maj) || !is_vector(beam_min) || !is_vector(beam_pa)) {
        print 'Error! Failed to get beamarea, beam_maj, beam_min and beam_pa!!\n' {}
        !sleep 9999999999999999999999999
        exit
    }


calc_buffer_size_limit 00
    #<20170923># determine the buffer size, which should be related to the FWHM of PSF
    if(is_vector(buffer_size_limit)) {unset buffer_size_limit}
    if(is_file("buffer_size_limit.txt")) {
        data "buffer_size_limit.txt" read {buffer_size_limit 1.f}
        if(!is_vector(buffer_size_limit)) {
            !rm "buffer_size_limit."* 2>/dev/null
        } # added a check here
    }
    if(!is_file("buffer_size_limit.txt") && is_file("image_sci_beamarea.txt")) {
        data "image_sci_beamarea.txt" read {temp_beamarea 1.f}
        if(!is_vector(pixscale)) {read_pixscale}
        set buffer_size_limit = 1.0*sqrt(temp_beamarea/(pi/(4.0*ln(2)))) / pixscale # pixel, set as 1.0xFWHM
        define print_noheader 1
        print "buffer_size_limit.txt" '%g\n' {buffer_size_limit}
        if(is_file("image_sci_beamarea.warning.txt")) {
        print "buffer_size_limit.warning.txt" 'The buffer size limit is estimated beamarea that has warning, see \"image_sci_beamarea.warning.txt\"!\n' {}
        }
        define print_noheader 0
    }


calc_fluxconv 00
    if(is_vector(fluxconv)) {unset fluxconv}
    if(is_file("image_sci_fluxconv.txt")) {
        data "image_sci_fluxconv.txt" read {fluxconv 1.f fluxunit 2.s}
        if(!is_vector(fluxconv)) {
            !rm "image_sci_fluxconv."* 2>/dev/null
        } # added a check here
    }
    if(!is_file("image_sci_fluxconv.txt") && is_file("image_sci.fits")) {
        !gethead "image_sci.fits" "BUNIT" > "image_sci_fluxunit.txt"
        if(is_vector(fluxunit)) {unset fluxunit}
        data "image_sci_fluxunit.txt" read {fluxunit 1.s}
        if(!is_vector(fluxunit)) {
            #<20180310># add a check for the TELESCOP
            !gethead "image_sci.fits" "TELESCOP" > "image_sci_telescop.txt"
            if(is_vector(telescop)) {unset telescop}
            data "image_sci_telescop.txt" read {telescop 1.s}
            if(is_vector(telescop)) {
                if(telescop=='ALMA') {
                    set fluxunit = 'Jy/beam'
                    !echo "Jy/beam" > "image_sci_fluxunit.txt"
                }
            }
        }
        if(is_vector(fluxunit)) {
            if(is_file("image_sci_fluxunit.warning.txt")) {!rm "image_sci_fluxunit.warning.txt"}
            if(fluxunit=='Jy/beam' || fluxunit=='JY/BEAM') {
                calc_beamarea
                read_pixscale
                set fluxconv = 1.0 / (beamarea/(pixscale*pixscale)) # assuming Jy/beam
                if(is_file("image_sci_fluxconv.warning.txt")) {!rm "image_sci_fluxconv.warning.txt"}
            } else {
                if(fluxunit=='MJy/sr' || fluxunit=='MJY/SR') {
                    set fluxconv = 1e6 * (pixscale/3600.0/180.0*pi)**2 # assuming MJy/sr
                    if(is_file("image_sci_fluxconv.warning.txt")) {!rm "image_sci_fluxconv.warning.txt"}
                } else {
                    set fluxconv = 1.0 / (beamarea/(pixscale*pixscale)) # assuming Jy/beam
                    print "image_sci_fluxconv.warning.txt" 'Could not understand BUNIT $(fluxunit)! Assuming Jy/beam!\n' {}
                }
            }
            print "image_sci_fluxconv.txt" '%0.15g   %s\n' {fluxconv fluxunit}
        } else {
            print "image_sci_fluxunit.warning.txt" 'No BUNIT keyword was found in the FITS header of image_sci.fits!\n' {}
            set fluxconv = 1.0
            set fluxunit = 'unknown'
            print "image_sci_fluxconv.txt" '%0.1g   %s\n' {fluxconv fluxunit}
            print "image_sci_fluxconv.warning.txt" 'No BUNIT keyword was found in the FITS header of image_sci.fits! Can not determine a valid fluxconv! Set to 1.0!\n' {}
        }
    }


calc_peak2total
    if(is_file("image_psf_peak2total.txt")) {
        #!mv "image_psf_peak2total.txt" "image_psf_peak2total.txt.backup"
        if(is_vector(peak2total)) {unset peak2total}
        verbose 0 data "image_psf_peak2total.txt" read {peak2total 1.f} verbose 1
        if(!is_vector(peak2total)) {!rm "image_psf_peak2total.txt"} # added a check here
    }
    if(!is_file("image_psf_peak2total.txt")) {
        if(is_vector(peak2total)) {unset peak2total}
        if(is_file("image_psf.fits")) {
            !CrabPhotImageStatistics -header-in-comment image_psf.fits > "image_psf_peak2total.tmp"
            if(is_vector(tmp_pix_max)) {unset tmp_pix_max}
            if(is_vector(tmp_pix_sum)) {unset tmp_pix_sum}
            verbose 0 data "image_psf_peak2total.tmp" read {tmp_pix_max 5 tmp_pix_sum 6} verbose 1
            if(is_vector(tmp_pix_max) && is_vector(tmp_pix_sum)) {
                set peak2total = tmp_pix_max / tmp_pix_sum
                define print_noheader 1
                print "image_psf_peak2total.txt" '%g\n' {peak2total}
                define print_noheader 0
            }
        }
    }











calc_Condon1997_errors 02
    # Condon 1997 - Errors of Gaussian Fitting - 1997PASP..109..166C.pdf
    # see also '/Users/dzliu/Cloud/Github/AlmaCosmos/Softwares/3rd_pybdsf/PyBDSF/bdsf/functions.py' def get_errors()
    # 20180309: fixed the bug when maj==0 or min==0
    if(is_vector(maj) && is_vector(min) && is_vector(convol_maj) && is_vector(convol_min) && \
        is_vector(beam_maj) && is_vector(beam_min) && is_vector(pixscale) && is_vector(pixnoise) && \
        is_vector(source_peak) && is_vector(source_total)) {
        # 
        set source_total_err = source_total*0.0 + pixnoise
        set source_peak_err = source_total*0.0 + pixnoise
        set source_major_err = source_total*0.0
        set source_minor_err = source_total*0.0
        set source_major_err_rel = source_total*0.0
        set source_minor_err_rel = source_total*0.0
        set source_gaussian_snr = source_total*0.0
        # 
        set Condon_h_area = pi/(2*ln(2))*(beam_maj/pixscale)*(beam_min/pixscale) # Condon1997 Eq(41,42)
        set Condon_s_area = pi/(2*ln(2))*(convol_maj/pixscale)*(convol_min/pixscale) # Condon1997 Eq(41,42)
        set Condon_h_maj = (1.0+(beam_maj**2)/(convol_maj**2)) # Condon1997 Eq(40,41)
        set Condon_h_min = (1.0+(beam_min**2)/(convol_min**2)) # Condon1997 Eq(40,41)
        set Condon_mu = pixnoise
        set Condon_A = source_peak
        set Condon_rho = calc_Condon1997_rho(1.5,1.5) # Condon1997 Eq(41)
        #set Condon_h_e = sqrt(Condon_h_area * Condon_h_maj**(-0.5) * Condon_h_min**(-0.5)) # Condon1997 Eq(40), the effective noise correlation area
        set source_peak_err = Condon_A * sqrt(2.0) / Condon_rho # Condon1997 Eq(21)
        set source_major_err_rel = 1.0 * sqrt(2.0) / calc_Condon1997_rho(2.5,0.5) # Condon1997 Eq(21), source_major_err = source_major * source_major_err_rel
        set source_minor_err_rel = 1.0 * sqrt(2.0) / calc_Condon1997_rho(0.5,2.5) # Condon1997 Eq(21), source_minor_err = source_minor * source_minor_err_rel
        set source_total_err_item_1 = (source_peak_err/source_peak)**2
        set source_total_err_item_2 = (Condon_h_area/Condon_s_area)*(source_major_err_rel**2)
        set source_total_err_item_3 = (Condon_h_area/Condon_s_area)*(source_minor_err_rel**2)
        set source_total_err = source_total * sqrt( source_total_err_item_1 + source_total_err_item_2 + source_total_err_item_3 ) # Condon1997 Eq(42)
        set source_gaussian_snr = Condon_rho
        # 
        if(sum((maj>0 && min>0))>0) {
            set Condon_i = 0,dimen(source_total)-1
            set Condon_i = Condon_i if(maj>0 && min>0)
            set source_major_err[Condon_i] = maj[Condon_i] * source_major_err_rel[Condon_i] # Condon1997 Eq(21)
            set source_minor_err[Condon_i] = min[Condon_i] * source_minor_err_rel[Condon_i] # Condon1997 Eq(21)
        }
    }

calc_Condon1997_rho 02
    if($?2) {
        # $1 is alpha_M
        # $2 is alpha_m
        # They are determined by Monte-Carlo simulations in Condon1997
        set $0 = sqrt((Condon_s_area)/(4*Condon_h_area) * Condon_h_maj**($1) * Condon_h_min**($2)) * Condon_A / Condon_mu # Condon1997 Eq(21,41)
        return
    }


calc_deconvolved_sizes 06
    # inputs: maj_convol, min_convol, PA_convol, maj_beam, min_beam, PA_beam
    # based on the ForTran code from eva, see email on 2018-01-09, subject "deconvolution".
    # <20180118>
    if($?6) {
        set calcds_Maj_convol = ($1)
        set calcds_Min_convol = ($2)
        set calcds_PA_convol = ($3)
        set calcds_Maj_beam = ($4)
        set calcds_Min_beam = ($5)
        set calcds_PA_beam = ($6)
        # c deconvolve the source size following AIPS
        set calcds_PA_convol_xl = ((calcds_PA_convol + 900.0) % 180.0)
        set calcds_PA_beam_xl = ((calcds_PA_beam + 900.0) % 180.0)
        set calcds_Maj_beam_square = calcds_Maj_beam**2
        set calcds_Min_beam_square = calcds_Min_beam**2
        set calcds_Maj_convol_square = calcds_Maj_convol**2
        set calcds_Min_convol_square = calcds_Min_convol**2
        set calcds_PA_diff = (calcds_PA_convol_xl - calcds_PA_beam_xl) / 90.0 * pi
        set calcds_cosc = cos(calcds_PA_diff)
        set calcds_sinc = sin(calcds_PA_diff)
        set calcds_rhoc = (calcds_Maj_convol_square-calcds_Min_convol_square) * calcds_cosc - (calcds_Maj_beam_square-calcds_Min_beam_square)
        if (calcds_rhoc == 0.0) {
           set calcds_sigic2 = 0.0
           set calcds_rhoa = 0.0
        } else {
           set calcds_sigic2 = atan((calcds_Maj_convol_square-calcds_Min_convol_square)*calcds_sinc/calcds_rhoc)
           #[dzliu]# calcds_sigic2 = atan( calcds_sinc / ( calcds_cosc - (calcds_Maj_beam_square-calcds_Min_beam_square)/(calcds_Maj_convol_square-calcds_Min_convol_square) ) )
           set calcds_rhoa = ((calcds_Maj_beam_square-calcds_Min_beam_square) - (calcds_Maj_convol_square-calcds_Min_convol_square) * calcds_cosc) / (2.0*cos(calcds_sigic2))
        }
        set calcds_PA_deconv = calcds_sigic2 * 90.0 / pi + calcds_PA_beam_xl
        set calcds_det = ((calcds_Maj_convol_square+calcds_Min_convol_square) - (calcds_Maj_beam_square+calcds_Min_beam_square)) / 2.0
        set calcds_Maj_deconv = calcds_det - calcds_rhoa
        set calcds_Min_deconv = calcds_det + calcds_rhoa
        set calcds_Maj_deconv = calcds_Maj_deconv > 0.0 ? calcds_Maj_deconv : 0.0
        set calcds_Min_deconv = calcds_Min_deconv > 0.0 ? calcds_Min_deconv : 0.0
        set calcds_Maj_deconv = sqrt(abs(calcds_Maj_deconv))
        set calcds_Min_deconv = sqrt(abs(calcds_Min_deconv))
        if (calcds_Maj_deconv < calcds_Min_deconv) {
           set calcds_Var_swap = calcds_Maj_deconv
           set calcds_Maj_deconv = calcds_Min_deconv
           set calcds_Min_deconv = calcds_Var_swap
           unset calcds_Var_swap
           set calcds_PA_deconv = calcds_PA_deconv + 90.0
        }
        set calcds_PA_deconv = ((calcds_PA_deconv+900.0) % 180.0)
        if (calcds_Maj_deconv == 0.0) {
           set calcds_PA_deconv = 0.0
        } else {
            if (calcds_Min_deconv == 0.0) {
                if ((abs(calcds_PA_deconv-calcds_PA_convol_xl) > 45.0) && (abs(calcds_PA_deconv-calcds_PA_convol_xl) < 135.0)) {
                    set calcds_PA_deconv = ((calcds_PA_deconv+450.0) % 180.0)
                }
           }
        }
        !printf \\"Maj convol, Maj beam => Maj deconv : \\033[0;31m\\t$(calcds_Maj_convol)\\033[0;0m, \\033[0;33m$(calcds_Maj_beam)\\033[0;0m => \\033[0;34m$(calcds_Maj_deconv)\\033[0;0m\\n\\"
        !printf \\"Min convol, Min beam => Min deconv : \\033[0;31m\\t$(calcds_Min_convol)\\033[0;0m, \\033[0;33m$(calcds_Min_beam)\\033[0;0m => \\033[0;34m$(calcds_Min_deconv)\\033[0;0m\\n\\"
        !printf \\"PA. convol, PA. beam => PA. deconv : \\033[0;31m\\t$(calcds_PA_convol)\\033[0;0m, \\033[0;33m$(calcds_PA_beam)\\033[0;0m => \\033[0;34m$(calcds_PA_deconv)\\033[0;0m\\n\\"
    }


calc_convolved_sizes 06
    # inputs: maj_deconv, min_deconv, PA_deconv, maj_beam, min_beam, PA_beam
    # based on the ForTran code from Eva, see email on 2018-01-09, subject "deconvolution".
    # reverted the process of deconvolution, so that the inputs are intrinsic sizes and outputs are convolved sizes
    # <20180118><20180226>
    # 
    # Assuming beam FWHM: B_maj, B_min, B_PA
    #     intrinsic FWHM: H_maj, H_min, H_PA
    #     convolved FWHM: C_maj, C_min, C_PA
    # We have
    #     (B_maj**2 + B_min**2) + (H_maj**2 + H_min**2) = (C_maj**2 + C_min**2)   --> verified by '/Users/dzliu/Cloud/Github/AlmaCosmos/Pipeline/a3cosmos-MC-simulation-calc-Gaussian-convolved-sizes/calc_Gaussian_convolved_sizes_Test_2_PA_diff_90.pro'
    #                                                                                         and '/Users/dzliu/Cloud/Github/AlmaCosmos/Pipeline/a3cosmos-MC-simulation-calc-Gaussian-convolved-sizes/calc_Gaussian_convolved_sizes_Test_3_PA_diff_45.pro'
    # ......
    # 
    if($?6) {
        set calcds_Maj_deconv = ($1)
        set calcds_Min_deconv = ($2)
        set calcds_PA_deconv = ($3)
        set calcds_Maj_beam = ($4)
        set calcds_Min_beam = ($5)
        set calcds_PA_beam = ($6)
        # 
        set calcds_sigic2 = (((calcds_PA_deconv + 900.0) % 180.0) - ((calcds_PA_beam + 900.0) % 180.0)) * 2.0 / 180.0 * pi
        # 
        set calcds_PA_diff = (((calcds_PA_deconv + 900.0) % 180.0) - ((calcds_PA_beam + 900.0) % 180.0))
        # 
        set calcds_sconv = (calcds_Maj_deconv**2+calcds_Min_deconv**2) + (calcds_Maj_beam**2+calcds_Min_beam**2)
        set calcds_sbeam = (calcds_Maj_beam**2+calcds_Min_beam**2)
        set calcds_dbeam = (calcds_Maj_beam**2-calcds_Min_beam**2)
        set calcds_dconv_times_dcos = (calcds_Maj_deconv**2-calcds_Min_deconv**2) * cos(calcds_sigic2) + calcds_dbeam
        set calcds_dconv_times_dsin = tan(calcds_sigic2) * (calcds_dconv_times_dcos-calcds_dbeam)
        set calcds_PA_diff = atan2(calcds_dconv_times_dsin,calcds_dconv_times_dcos) / 2.0 / pi * 180.0
        set calcds_dcos = cos(2*calcds_PA_diff/180.0*pi)
        set calcds_dsin = sin(2*calcds_PA_diff/180.0*pi)
        set calcds_dconv = calcds_dconv_times_dcos / calcds_dcos
        #if dcos != 0.0:
        #    dconv = dconv_times_dcos / dcos
        #else:
        #    dconv = dconv_times_dsin / dsin
        # 
        set calcds_PA_convol = calcds_PA_diff + ((calcds_PA_beam + 900.0) % 180.0)
        set calcds_Maj_convol2 = (calcds_sconv + calcds_dconv)/2.0 # dconv = (Maj_convol**2-Min_convol**2), sconv = (Maj_convol**2+Min_convol**2), so ...
        set calcds_Min_convol2 = (calcds_sconv - calcds_dconv)/2.0 # dconv = (Maj_convol**2-Min_convol**2), sconv = (Maj_convol**2+Min_convol**2), so ...
        set calcds_Maj_convol = (calcds_Maj_convol2 >= calcds_Min_convol2) ? sqrt(calcds_Maj_convol2) : sqrt(calcds_Min_convol2)
        set calcds_Min_convol = (calcds_Maj_convol2 >= calcds_Min_convol2) ? sqrt(calcds_Min_convol2) : sqrt(calcds_Maj_convol2)
        # 
        !printf \\"Maj deconv, Maj beam => Maj convol : \\033[0;31m\\t$(calcds_Maj_deconv)\\033[0;0m, \\033[0;33m$(calcds_Maj_beam)\\033[0;0m => \\033[0;34m$(calcds_Maj_convol)\\033[0;0m\\n\\"
        !printf \\"Min deconv, Min beam => Min convol : \\033[0;31m\\t$(calcds_Min_deconv)\\033[0;0m, \\033[0;33m$(calcds_Min_beam)\\033[0;0m => \\033[0;34m$(calcds_Min_convol)\\033[0;0m\\n\\"
        !printf \\"PA. deconv, PA. beam => PA. convol : \\033[0;31m\\t$(calcds_PA_deconv)\\033[0;0m, \\033[0;33m$(calcds_PA_beam)\\033[0;0m => \\033[0;34m$(calcds_PA_convol)\\033[0;0m\\n\\"
    }















mask_prior_sources 01
    # 
    # This subroutine reads the "getpix.txt" and "getpix.result" files
    # and mask prior sources according to the "getpix" S/N
    # 
    # The input argument is the suffix of data files, 
    # for example, 
    # mask_prior_sources _on_negative_images
    # 
    if($?1) {
        define output_file No_catalog_source_with_enough_getpix_SNR$1
        define input_file getpix$1
    } else {
        define output_file No_catalog_source_with_enough_getpix_SNR
        define input_file getpix
    }
    if(is_file($output_file)) { !rm $output_file }
    if(is_file($input_file.txt) && is_file($input_file.result) && is_vector(px) && is_vector(py)) {
        data $input_file.txt read {f_000 1.f}
        data $input_file.result read {f_peak 1.f f_total 2.f snr_peak 3.f snr_total 4.f cat_index 7.f cat_id 8.s}
        #set mask = (snr_total>=1.0 && snr_peak>=2.0) #<before><20170403><dzliu>#
        # 
        #<20170923># allow to set the threshold by files "fit_galfit_prior_peak_snr" and "fit_galfit_prior_total_snr"
        #<20170923># set threshold_total = 2.0
        #<20170923># set threshold_peak = 3.6
        if(is_file("fit_galfit_prior_peak_snr")) {
            data "fit_galfit_prior_peak_snr" read {threshold_peak 1.f}
        } else {
            set threshold_peak = 3.6 * 0.7
            print "fit_galfit_prior_peak_snr" {threshold_peak}
        }
        if(is_file("fit_galfit_prior_total_snr")) {
            data "fit_galfit_prior_total_snr" read {threshold_total 1.f}
        } else {
            set threshold_total = 2.0 * 0.7
            print "fit_galfit_prior_total_snr" {threshold_total}
        }
        if(is_file("fit_galfit_prior_combined_peak_and_total_snr")) {
            data "fit_galfit_prior_combined_peak_and_total_snr" read {threshold_comb_peak 1.f threshold_comb_total 2.f}
        } else {
            set threshold_comb_peak = 3.6 * 0.45
            set threshold_comb_total = 2.0 * 0.45
            print "fit_galfit_prior_combined_peak_and_total_snr" {threshold_comb_peak threshold_comb_total}
        }
        # 
        #set mask = ((snr_total/threshold_total>=0.35 && snr_peak/threshold_peak>=0.35) || (snr_total/threshold_total>=0.75) || (snr_peak/threshold_peak>=0.75)) #<before><20170607><dzliu>#
        #set mask = ((snr_total/threshold_total>=0.30 && snr_peak/threshold_peak>=0.30) || (snr_total/threshold_total>=0.70) || (snr_peak/threshold_peak>=0.70)) #<before><20170923><dzliu>#
        set mask = ((snr_total>=threshold_comb_total && snr_peak>=threshold_comb_peak) || \
                    (snr_total>=threshold_total) || \
                    (snr_peak>=threshold_peak))
        set mask = (mask && f_000!=0) #<20170719># this excludes sources at invalid pixel position
        set mask = int(mask)
        set id = float(id)
        print $input_file.mask '%15d %15.0f %15.0f %20s\n' {mask id cat_index cat_id} # TODO Check: id == cat_index = cat_id-1
        echo "Writing "$(dimen(cat_id))" lines to "$input_file.mask
        # 
        if(sum(mask)>0) {
            set px = px if(mask)
            set py = py if(mask)
            set id = id if(mask) # this is the catalog index from 0 to dimen(catalog)-1, not catalog object id itself
            # 
            set cat_index = cat_index if(mask)
            set cat_id = cat_id if(mask)
            # 
            if(is_file("image_sci_primary_beam_correction.txt")) {
                data "image_sci_primary_beam_correction.txt" read {pb_corr 1.f}
                set pb_corr = pb_corr if(mask)
            } else {
                set pb_corr = px*0.0 + 1.0
            }
            # 
            if(is_file("image_pba_primary_beam_correction.txt")) {
                data "image_pba_primary_beam_correction.txt" read {pb_corr_from_pb_image 1.f}
                set pb_corr_from_pb_image = pb_corr_from_pb_image if(mask)
            } else {
                set pb_corr_from_pb_image = px*0.0 + 1.0
            }
            # 
        } else {
            declare px 0.f
            declare py 0.f
            declare id 0.f
            declare pb_corr 0.f
            declare pb_corr_from_pb_image 0.f
            print $output_file 'No catalog source with enough getpix SNR.\n' {}
            echo "Warning! No catalog source with enough getpix SNR."
            return # exit
        }
    } else {
        print 'Warning! \"$input_file.txt\" or \"$input_file.result\" was not found! We will not mask the prior sources based on that!\n' {}
    }


mask_prior_sources_on_negative_image 00
    # same as the previous subroutine but for negative image
    mask_prior_sources _on_negative_image






go_galfit_0
    go_galfit 0

go_galfit_1
    go_galfit 1

go_galfit_2
    go_galfit 2

go_galfit_3
    go_galfit 3

go_galfit_4
    go_galfit 4

go_galfit_n0
    go_galfit n0

go_galfit_n1
    go_galfit n1

go_galfit_n2
    go_galfit n2

go_galfit_n3
    go_galfit n3

go_galfit_n4
    go_galfit n4

go_galfit 01
    # 
    # this subroutine prepare necessary files for running galfit 
    # 
    # the first argument is the step code, 
    # 0 for fixed position PSF fitting, 
    # 1 for varied position PSF fitting, 
    # 2 for varied position gaussian fitting, 
    # 3 for varied position sersic n=1 (exponential disk) fitting. 
    # 
    if(!$?1) {
        print 'Usage: go_galfit 0\n' {}
        return
    }
    read_data
    read_pixscale
    read_pixnoise
    calc_fluxconv
    # 
    # mask prior sources (20171221: fixed bug: mask_prior_sources_on_negative_image)
    if(index('$1','n')==0) {
        mask_prior_sources_on_negative_image
    } else {
        mask_prior_sources
    }
    # --> px, py, id, cat_index, cat_id, pb_corr, pb_corr_from_pb_image
    # 
    #<20171221># print fit_$1.cat_index.txt '%15.0f %20s\n' {cat_index cat_id}
    #<20171221># print fit_$1.pbcorr.txt '%15g %15.0f %20s\n' {pb_corr cat_index cat_id}
    #<20171221># print fit_$1.pbcorr.from.pb.image.txt '%22g %15.0f %20s\n' {pb_corr_from_pb_image cat_index cat_id}
    #<20171221># print fit_$1.result.pbc.txt '%25g %15g %15.0f %20s\n' {pb_corr_from_pb_image pb_corr cat_index cat_id}
    #<20171221># echo "Writing "$(dimen(cat_id))" lines to "fit_$1.cat_index.txt
    #<20171221># echo "Writing "$(dimen(cat_id))" lines to "fit_$1.pbcorr.txt
    #<20171221># echo "Writing "$(dimen(cat_id))" lines to "fit_$1.pbcorr.from.pb.image.txt
    #<20171221># echo "Writing "$(dimen(cat_id))" lines to "fit_$1.result.pbc.txt
    #<20171221># -- we can not name it "fit_$1.result.pbc.txt" otherwise it will get deleted at the begining of "print_result" by the code "!rm $1.result*"!!!
    !rm fit_$1.pbcorr* 2>/dev/null
    print fit_$1.cat_index.txt              '%15.0f %20s\n'             {cat_index cat_id}
    print fit_$1.pb_corr_from_calc.txt      '%15g %15.0f %20s\n'        {pb_corr cat_index cat_id}
    print fit_$1.pb_corr_from_pb_image.txt  '%22g %15.0f %20s\n'        {pb_corr_from_pb_image cat_index cat_id}
    print fit_$1.pb_corr.txt                '%25g %15g %15.0f %20s\n'   {pb_corr_from_pb_image pb_corr cat_index cat_id}
    echo "Writing "$(dimen(cat_id))" lines to "fit_$1.cat_index.txt
    echo "Writing "$(dimen(cat_id))" lines to "fit_$1.pb_corr_from_calc.txt
    echo "Writing "$(dimen(cat_id))" lines to "fit_$1.pb_corr_from_pb_image.txt
    echo "Writing "$(dimen(cat_id))" lines to "fit_$1.pb_corr.txt
    # 
    if(dimen(px)>0 && dimen(py)==dimen(px)) {
        if('$1'=='0' || '$1'=='n0') {
            initGalfitParam px py
            set Mags = float(px) * 0.0 + 8.0 #<20170228># initial magnitude ~8.0
        } else {
            # read previous galfit result
            define previous_fit none
            if('$1'=='1' ) { define previous_fit fit_0  }
            if('$1'=='n1') { define previous_fit fit_n0 }
            if('$1'=='2' ) { define previous_fit fit_1  }
            if('$1'=='n2') { define previous_fit fit_n1 }
            if('$1'=='3' ) { define previous_fit fit_2  }
            if('$1'=='n3') { define previous_fit fit_n2 }
            if('$1'=='4' ) { define previous_fit fit_3  }
            if('$1'=='n4') { define previous_fit fit_n3 }
            if('$previous_fit'=='none') {
                print 'Error! Could not determine the previous galfit step for the input step \"fit_$1\"!\n' {}
                print 'Recognizable input steps are fit_1, fit_n1, fit_2, fit_n2, fit_3, fit_n3!\n' {}
                return
            }
            if(!is_file($previous_fit.result)) {
                print 'Error! The previous step galfit result \"$previous_fit.result\" was not found!\n' {}
                return
            }
            if(!is_file($previous_fit.result.chisq.txt)) {
                print 'Error! The previous step galfit result \"$previous_fit.result.chisq.txt\" was not found!\n' {}
                return
            }
            data $previous_fit.result
            read {ResultPosX 1.f ResultPosY 2.f ResultFlux 3.f ResultMags 7.f ResultMagsErr 8.f ResultRads 9.f ResultMiAs 11.f ResultRoti 13.f ResultPixScale 15.f ResultPixArea 16.f}
            set ResultElli = (ResultRads>0) ? ResultRads : -99
            set ResultElli = (ResultRads>0) ? ResultMiAs / ResultElli : 1.0
            data $previous_fit.result.chisq.txt
            read {ResultFluxRedChisq 2.f}
            # 
            # 20191223 allow user to tune maximum allowed varied position
            if(is_file("fit_galfit_prior_vary_position_maximum_arcsec")) {
                data "fit_galfit_prior_vary_position_maximum_arcsec" read {maximum_vary_arcsec 1.f}
            } else {
                set maximum_vary_arcsec = 0.7
                print "fit_galfit_prior_vary_position_maximum_arcsec" {maximum_vary_arcsec}
            }
            # 
            # allow vary
            set Allow_To_Vary = (ResultMagsErr>0 && ResultMagsErr<0.33) || (ResultMags<-2.5*lg(3.0*pixnoise/fluxconv)) #<TODO># 
            set Vary_X = (Allow_To_Vary) ? maximum_vary_arcsec/abs(pixscale) : 0 # maximum 0.7 arcsec #<before><20171123># maximum 0.5 arcsec
            set Vary_Y = (Allow_To_Vary) ? maximum_vary_arcsec/abs(pixscale) : 0 # maximum 0.7 arcsec #<before><20171123># maximum 0.5 arcsec
            set Vary_X = (Vary_X>20) ? 20 : Vary_X # maximum 20 pixel, i.e. only valid when pixscale < 0.025 arcsec. #<added><20170607><dzliu>#
            set Vary_Y = (Vary_Y>20) ? 20 : Vary_Y # maximum 20 pixel, i.e. only valid when pixscale < 0.025 arcsec. #<added><20170607><dzliu>#
            initGalfitParam px py Vary_X Vary_Y
            set Mags = float(px) * 0.0 + 8.0 #<20170228># initial magnitude ~8.0
            set Rads = float(px) * 0.0 + 0.0 #<20170228># initial radius ~0.0, meaning that no size
            set ParamFitMags = float(px) * 0 + 1
            set ParamFitRads = float(px) * 0 + 0
            set ParamMinMags = float(Mags)*0.0 - 30.0
            set ParamMaxMags = float(Mags)*0.0 + 30.0
            set ParamMinRads = float(Rads)*0.0 + 1.0 # minimum 1.0 pixel FWHM #<20170613># prev. using 0.5 pix causes 'nan' error!
            set ParamMaxRads = float(Rads)*0.0 + 3.0/abs(pixscale) # maximum 3.0 arcsec FWHM #<20171009># prev. using 5.0 arcsec #<20170613># prev. using 3.5 arcsec
            # 
            if('$1'=='1' || '$1'=='n1') { 
                # varied position PSF
                if(is_file("fit_galfit_prior_vary_position_threshold_magerr")) {
                    data "fit_galfit_prior_vary_position_threshold_magerr" read {threshold_magerr 1.f}
                } else {
                    set threshold_magerr = 0.25
                    print "fit_galfit_prior_vary_position_threshold_magerr" {threshold_magerr}
                }
                if(is_file("fit_galfit_prior_vary_position_threshold_totrms")) {
                    data "fit_galfit_prior_vary_position_threshold_totrms" read {threshold_totrms 1.f}
                } else {
                    set threshold_totrms = 3.0
                    print "fit_galfit_prior_vary_position_threshold_totrms" {threshold_totrms}
                }
                set Allow_To_Use_Preivous_Mags = ((ResultMagsErr>0 && ResultMagsErr<threshold_magerr) || (ResultMags<-2.5*lg(threshold_totrms*pixnoise/fluxconv))) && (ResultMags<Mags) #<TODO># 
                set Mags = (Allow_To_Use_Preivous_Mags) ? ResultMags : Mags # use previous step magnitude results
            }
            if('$1'=='2' || '$1'=='n2') { 
                # elliptic Gaussian
                if(is_file("fit_galfit_prior_fit_gaussian_threshold_magerr")) {
                    data "fit_galfit_prior_fit_gaussian_threshold_magerr" read {threshold_magerr 1.f}
                } else {
                    set threshold_magerr = 0.20
                    print "fit_galfit_prior_fit_gaussian_threshold_magerr" {threshold_magerr}
                }
                if(is_file("fit_galfit_prior_fit_gaussian_threshold_totrms")) {
                    data "fit_galfit_prior_fit_gaussian_threshold_totrms" read {threshold_totrms 1.f}
                } else {
                    set threshold_totrms = 3.0
                    print "fit_galfit_prior_fit_gaussian_threshold_totrms" {threshold_totrms}
                }
                set Allow_To_Fit_Gaussian = ((ResultMagsErr>0 && ResultMagsErr<threshold_magerr) || (ResultMags<-2.5*lg(threshold_totrms*pixnoise/fluxconv))) #<TODO># 
                set Mags         = (Allow_To_Fit_Gaussian && ResultMags<Mags)  ? ResultMags         : Mags # use previous step magnitude results, but only when the fitted magnitude is not fainter than the initial magnitude
                set Type         = (Allow_To_Fit_Gaussian)                     ? 'gaussian'         : Type
                set Rads         = (Allow_To_Fit_Gaussian)                     ? 0.25/abs(pixscale) : Rads # initial guess 0.25 arcsec Gaussian FWHM #<before><20171123># 0.5 arcsec
                set Rads         = (Allow_To_Fit_Gaussian && ResultRads>0)     ? ResultRads         : Rads # use previous Gaussian FWHM if possible
                set Elli         = (Allow_To_Fit_Gaussian)                     ? 1.0                : Elli # initial guess of b/a ratio: 1.0
                set Roti         = (Allow_To_Fit_Gaussian)                     ? 0.0                : Roti # initial guess of position angle: 0.0 degree
                set ParamFitRads = (Allow_To_Fit_Gaussian)                     ? 1                  : ParamFitRads
                set ParamFitElli = (Allow_To_Fit_Gaussian)                     ? 1                  : ParamFitElli
                set ParamMinElli = (Allow_To_Fit_Gaussian)                     ? 0.2                : ParamMinElli # b/a ratio, i.e. q in galfit input file
                set ParamMaxElli = (Allow_To_Fit_Gaussian)                     ? 1.0                : ParamMaxElli # b/a ratio, i.e. q in galfit input file
                set ParamFitRoti = (Allow_To_Fit_Gaussian)                     ? 1                  : ParamFitRoti
                set ParamMinRoti = (Allow_To_Fit_Gaussian)                     ? -360.0             : ParamMinRoti
                set ParamMaxRoti = (Allow_To_Fit_Gaussian)                     ? 360.0              : ParamMaxRoti
            }
            if('$1'=='3' || '$1'=='n3') { 
                # elliptic sersic
                if(is_file("fit_galfit_prior_fit_sersic_threshold_magerr")) {
                    data "fit_galfit_prior_fit_sersic_threshold_magerr" read {threshold_magerr 1.f}
                } else {
                    set threshold_magerr = 0.20
                    print "fit_galfit_prior_fit_sersic_threshold_magerr" {threshold_magerr}
                }
                if(is_file("fit_galfit_prior_fit_sersic_threshold_totrms")) {
                    data "fit_galfit_prior_fit_sersic_threshold_totrms" read {threshold_totrms 1.f}
                } else {
                    set threshold_totrms = 3.0
                    print "fit_galfit_prior_fit_sersic_threshold_totrms" {threshold_totrms}
                }
                set Allow_To_Fit_Sersic = ((ResultMagsErr>0 && ResultMagsErr<threshold_magerr) || (ResultMags<-2.5*lg(threshold_totrms*pixnoise/fluxconv))) #<TODO># 
                set Mags         = (Allow_To_Fit_Sersic && ResultMags<Mags)                              ? ResultMags                     : Mags # use previous step magnitude results, but only when the fitted magnitude is not fainter than the initial magnitude
                set Mags         = (Allow_To_Fit_Sersic && ResultFluxRedChisq>=2.0)                      ? ResultMags-2.5*lg(0.5)         : Mags # use previous step magnitude results, but note that for bad chisq sources we need to set fainter starting magnitude
                set Type         = (Allow_To_Fit_Sersic)                                                 ? 'sersic'                       : Type
                set Rads         = (Allow_To_Fit_Sersic)                                                 ? 0.25/abs(pixscale)/2.0         : Rads # initial guess 0.25 arcsec Gaussian FWHM #<before><20171123># 0.5 arcsec
                set Rads         = (Allow_To_Fit_Sersic && ResultRads>0.0 && ResultFluxRedChisq<=2.0)    ? ResultRads/ResultPixScale/2.0  : Rads # use previous Gaussian FWHM if possible, but note that for bad chisq sources we might better fall back to the default initial guess. Also, note that galfit Sersic Radius = Gaussian FWHM / 2.0
                set Elli         = (Allow_To_Fit_Sersic)                                                 ? 1.0                            : Elli # initial guess of b/a ratio: 1.0
                set Elli         = (Allow_To_Fit_Sersic && ResultRads>0.0 && ResultFluxRedChisq<=2.0)    ? ResultElli                     : Elli # use previous Gaussian b/a ratio if possible, but note that for bad chisq sources we might better fall back to the default initial guess
                set Roti         = (Allow_To_Fit_Sersic)                                                 ? 0.0                            : Roti # initial guess of position angle: 0.0 degree
                set Roti         = (Allow_To_Fit_Sersic && ResultRads>0.0 && ResultFluxRedChisq<=2.0)    ? ResultRoti                     : Roti # use previous position angle if possible, but note that for bad chisq sources we might better fall back to the default initial guess
                set Sers         = (Allow_To_Fit_Sersic)                                                 ? 1.0                            : Sers # initial guess of Sersic n index: 1.0
                set ParamFitRads = (Allow_To_Fit_Sersic)                                                 ? 1                              : ParamFitRads
                set ParamFitElli = (Allow_To_Fit_Sersic)                                                 ? 1                              : ParamFitElli
                set ParamMinElli = (Allow_To_Fit_Sersic)                                                 ? 0.2                            : ParamMinElli # b/a ratio, i.e. q in galfit input file
                set ParamMaxElli = (Allow_To_Fit_Sersic)                                                 ? 1.0                            : ParamMaxElli # b/a ratio, i.e. q in galfit input file
                set ParamFitRoti = (Allow_To_Fit_Sersic)                                                 ? 1                              : ParamFitRoti
                set ParamMinRoti = (Allow_To_Fit_Sersic)                                                 ? -360.0                         : ParamMinRoti
                set ParamMaxRoti = (Allow_To_Fit_Sersic)                                                 ? 360.0                          : ParamMaxRoti
                set ParamFitSers = (Allow_To_Fit_Sersic)                                                 ? 0                              : ParamFitSers # do not fit Sersic index n
            }
        }
        # 
        set Note = cat_id # cat_id is created by the 'mask_prior_sources' subroutine
        set ParamCoB = 5.0/abs(pixscale) #<20170303><dzliu><plang># set convolution box of about 5 arcsec
        set ParamCoB = (ParamCoB<25) ? 25 : ParamCoB #<20170730><dzliu># prevent too small value
        set ParamCoB = (ParamCoB>350) ? 350 : ParamCoB #<20170730><dzliu># prevent too big value
        # 
        # allow to fit sky background <20170919>
        if(is_file("fit_sky_background")) {
            set ParamFitSkyValue = 1
        }
        # 
        if(is_file(galfit.01)) {!rm galfit.*}
        if(is_file(fit.log)) {!rm fit.log}
        writeGalfitParam fit_$1.param
        writeGalfitLimit fit_$1.limit
        #<BUG><20180109><DZLIU># WRONGLY USED image_sci.fits IN NEGATIVE FITTING MODE
        if(index('$1','n')==0) {
            writeGalfitInput fit_$1.input image_negative.fits fit_$1.fits image_rms.fits image_psf.fits image_nan_mask.fits fit_$1.limit
        } else {
            writeGalfitInput fit_$1.input image_sci.fits fit_$1.fits image_rms.fits image_psf.fits image_nan_mask.fits fit_$1.limit
        }
        exec_galfit $1
        if(is_file(fit_$1.fits)) {
            readGalfitResult fit_$1.fits
            print_result fit_$1
        }
    }






exec_galfit 01
    # usage: 
    #   exec_galfit 0
    #   exec_galfit 1
    #   exec_galfit 2
    #   exec_galfit 3
    # 
    if($?1) {
        # 
        # check previous files
        if(is_file("fit_"$1".failed")) {
            !mv "fit_"$1".failed" "fit_"$1".failed.backup"
        }
        if(is_file("fit_"$1".log")) {
            !mv "fit_"$1".log" "fit_"$1".log.backup"
        }
        # 
        # exec galfit
        if(is_file("fit_"$1"_with_galfit255") || is_file("fit_with_galfit255")) {
            !galfit255 fit_$1.input > fit_$1.out 2>&1
        } else {
            if(is_file("fit_"$1"_with_galfit30") || is_file("fit_with_galfit30")) {
                !galfit30 fit_$1.input > fit_$1.out 2>&1
            } else {
                !galfit fit_$1.input > fit_$1.out 2>&1
            }
        }
        # 
        # get fit.log
        if(is_file(fit.log)) {
            !mv fit.log "fit_"$1".log"
        } else {
            !date +\\"%Y-%m-%d %H:%M:%S %Z\\" > "fit_"$1".failed"
            !echo "Failed to fit with galfit! fit.log was not found!" >> "fit_"$1".failed"
            return
        }
        # 
        # check if fit.log contains nan or not
        #<BUGGY><20171209># !cat "fit_"$1".log" | grep -q -r "\\\bnan\\\b"
        !grep -q -r "\\\bnan\\\b" "fit_"$1".log"
        if($exit_status==0) {
            # found nan!
            # re-do galfit
            if(!is_file("fit_"$1"_with_galfit30") && !is_file("fit_with_galfit30") && !is_file("fit_"$1"_with_galfit255") && !is_file("fit_with_galfit255")) {
                !touch "fit_"$1"_with_galfit30"
                exec_galfit $1
            } else {
                if(!is_file("fit_"$1"_with_galfit255") && !is_file("fit_with_galfit255")) {
                    !touch "fit_"$1"_with_galfit255"
                    exec_galfit $1
                } else {
                    !date +\\"%Y-%m-%d %H:%M:%S %Z\\" > "fit_"$1".failed"
                    !echo "Failed to fit with galfit! fit.log contains nan!" >> "fit_"$1".failed"
                }
            }
        }
    }






print_result 02
    # 
    # this subroutine reads galfit output "fit_X.fits" and prints results to "fit_X.result" text file. 
    # 
    # input argument $1 -- fit_XXX
    # 
    read_pixscale
    read_pixnoise
    calc_beamarea
    #calc_peak2total
    calc_fluxconv
    # 
    if(is_file($1.result)) {
        !rm $1.result*
    }
    # 
    # <20170613> getpix f_peak
    if(is_file($1.fits)) {
        !CrabFitsImageArithmetic $1.fits -ext 2 times 1.0 $1.model.fits -copy-wcs > $1.model.fits.log
        #!cphead -v image_sci.fits $1.model.fits "CTYPE1" "CRVAL1" "CDELT1" "CRPIX1" "CUNIT1" "CTYPE2" "CRVAL2" "CDELT2" "CRPIX2" "CUNIT2" > $1.model.fits.cphead.log 2>&1
    }
    # 
    # <20170719> getpix f_res
    if(is_file($1.fits)) {
        !CrabFitsImageArithmetic $1.fits -ext 3 times 1.0 $1.residual.fits -copy-wcs > $1.residual.fits.log
        #!cphead -v image_sci.fits $1.residual.fits "CTYPE1" "CRVAL1" "CDELT1" "CRPIX1" "CUNIT1" "CTYPE2" "CRVAL2" "CDELT2" "CRPIX2" "CUNIT2" > $1.residual.fits.cphead.log 2>&1
    }
    # 
    if(is_vector(ResultMags) && is_vector(ResultMagsErr) && is_vector(ResultPosX) && is_vector(ResultPosY) && $?1) {
        set ResultFlux = ResultMags*0.0 + 1e-30
        set ResultFluxErr = ResultMags*0.0 + 1e+30
        set ResultFluxPeak = ResultMags*0.0 + 1e-30 # <20170613> getpix f_peak
        set ResultFluxOrigin = ResultMags*0.0==0.0 ? 'nan' : 'nan' # <20170613> getpix f_origin, flux in the original image_sci_input.fits
        do i=0,dimen(ResultMags)-1 {
            if(ResultType[$i]=='psf') {
                # In this case (10**(ResultMags/(-2.5))) equals the (pix_max / peak2total)
                set ResultFlux[$i] = (10**(ResultMags[$i]/(-2.5))) * fluxconv #<20170923># / beamarea * (pixscale*pixscale) # * peak2total
                set ResultFluxErr[$i] = (ResultMagsErr[$i]>=0) ? ResultMagsErr[$i]*ResultFlux[$i]/1.08 : ResultFluxErr[$i] #<20171206><BUG><FIXED># nan (-99) ResultMagsErr problem
                # Get peak flux from source model fits image
                !getpix '%15.10e' $1.model.fits $(ResultPosX[$i]) $(ResultPosY[$i]) > aaa.getpix.tmp
                verbose 0 data aaa.getpix.tmp read {fluxpeak 1.f}
                verbose 1 !rm aaa.getpix.tmp
                set ResultFluxPeak[$i] = fluxpeak # Jy/beam <20170613>
                # Get original image pixel value (prevent from at NaN pixel position)
                if(index('$1','n')==0) {
                    !getpix '%15.10e' image_negative_input.fits $(ResultPosX[$i]) $(ResultPosY[$i]) > aaa.getpix.tmp
                } else {
                    !getpix '%15.10e' image_sci_input.fits $(ResultPosX[$i]) $(ResultPosY[$i]) > aaa.getpix.tmp
                }
                verbose 0 data aaa.getpix.tmp read {fluxorigin 1.s} #<20180613># bug --> should read as str instead of float
                verbose 1 !rm aaa.getpix.tmp
                set ResultFluxOrigin[$i] = fluxorigin # Jy/beam <20180109>
            }
            if(ResultType[$i]=='gaussian' || ResultType[$i]=='sersic') {
                # In this case (10**(ResultMags/(-2.5))) equals the (pix_sum)
                set ResultFlux[$i] = (10**(ResultMags[$i]/(-2.5))) * fluxconv #<20170923># / beamarea * (pixscale*pixscale) # * (pi/(4*ln(2))*ResultRads[$i]*ResultRads[$i]*ResultElli[$i]) #<20170303><dzliu># must correct Jy/beam -> Jy/pixel for Gaussian fitting
                set ResultFluxErr[$i] = (ResultMagsErr[$i]>=0) ? ResultMagsErr[$i]*ResultFlux[$i]/1.08 : ResultFluxErr[$i] #<20171206><BUG><FIXED># nan (-99) ResultMagsErr problem
                # Get peak flux from source model fits image
                !getpix '%15.10e' $1.model.fits $(ResultPosX[$i]) $(ResultPosY[$i]) > aaa.getpix.tmp
                verbose 0 data aaa.getpix.tmp read {fluxpeak 1.f}
                verbose 1 !rm aaa.getpix.tmp
                set ResultFluxPeak[$i] = fluxpeak # Jy/beam <20170613>
                # Get original image pixel value (prevent the source from being at a position where the pixel value is NaN, e.g., at the edge of the circular area cut by ALMA pipeline for the primary beam attenation.)
                if(index('$1','n')==0) {
                    !getpix '%15.10e' image_negative_input.fits $(ResultPosX[$i]) $(ResultPosY[$i]) > aaa.getpix.tmp
                } else {
                    !getpix '%15.10e' image_sci_input.fits $(ResultPosX[$i]) $(ResultPosY[$i]) > aaa.getpix.tmp
                }
                verbose 0 data aaa.getpix.tmp read {fluxorigin 1.s}
                verbose 1 !rm aaa.getpix.tmp
                set ResultFluxOrigin[$i] = fluxorigin # Jy/beam <20180109>
            }
            if(ResultMags[$i]>=30) {
                set ResultFlux[$i] = 1e-30 #<20170303><dzliu># 
            }
        }
        # 
        # <20170719> getpix ResultNumbFreeParam
        set ResultNumbFreeParam = int(ResultMags*0)
        do i=0,dimen(ResultMags)-1 {
            if(ResultNumbFreeParam[$i]==0 && ResultType[$i]=='psf') {
                if(ResultPosXErr[$i]<=0 && ResultPosYErr[$i]<=0) {
                    set ResultNumbFreeParam[$i] = 1
                } else {
                    set ResultNumbFreeParam[$i] = 3
                }
            }
            if(ResultNumbFreeParam[$i]==0 && ResultType[$i]=='gaussian') {
                set ResultNumbFreeParam[$i] = 6
            }
            if(ResultNumbFreeParam[$i]==0 && ResultType[$i]=='sersic') {
                set ResultNumbFreeParam[$i] = (ResultSersErr[$i]>0) ? 7 : 6
            }
        }
        # 
        # <20170719> getpix f_res -- for each object, with an aperture of diameter 1.0 arcsec
        load fresidual.sm
        set ResultFluxResAbs = fresidual_inPixel($1.residual.fits, ResultPosX, ResultPosY, $(1.0/pixscale))
        if(dimen(ResultFluxResAbs)!=dimen(ResultPosX)) {
            print '\nError! Failed to call fresidual_inPixel()! Maybe it is because of multiple running supermongo! Please re-run!\n\n' {}
            exit
        }
        # 
        # <20170719> getpix f_chi2 -- for each object, with an aperture of diameter 1.0 arcsec
        load fresidual.sm
        set ResultFluxResChisq = (_fresipix_rms)**2 * _fresipix_npix / pixnoise**2 # chi-sq = sum(pixresidual**2/pixnoise**2), sqrt(sum(pixresidual**2)/npix) is just _fresipix_rms from 'fresidual_inPixel()'. 
        set ResultFluxRedChisq = ResultFluxResChisq / (_fresipix_npix - ResultNumbFreeParam) # reduced chi-sq, = chi-sq / N_DOF, N_DOF = npix - 
        set ResultFluxNumPixel = float(_fresipix_npix)
        # 
        # read cat_index and cat_id (str)
        data $1.cat_index.txt read {cat_index 1.f cat_id 2.s}
        # 
        # read pb_corr from fit_$1.result.pbc.txt, which is produced by go_galfit
        #data $1.pbcorr.txt read {pb_corr 2.f} -- <20171221><BUG><FIXED> Buggy!!! It was actually read from $1.pbcorr.txt!!! Should read from $1.result.pbc.txt!!!
        data $1.pb_corr.txt read {pb_corr 2.f}
        # 
        # 
        set x = ResultPosX
        set y = ResultPosY
        set f = ResultFlux
        set f_err = ResultFluxErr
        set mag = ResultMags
        set mag_err = ResultMagsErr
        set maj = ResultRads * pixscale
        set maj_err = ResultRadsErr * pixscale
        set maj_pix = maj / pixscale
        set min = maj*ResultElli
        set min_err = maj*ResultElliErr
        set min_pix = min / pixscale
        set pa = ResultRoti
        set pa_err = ResultRotiErr
        set sersic_n = ResultSers
        set sersic_n_err = ResultSersErr
        if(sum(sersic_n>0)>0) {
            set maj     = (sersic_n>0) ? maj*2.0     : maj
            set maj_err = (sersic_n>0) ? maj_err*2.0 : maj_err
            set maj_pix = (sersic_n>0) ? maj_pix*2.0 : maj_pix
            set min     = (sersic_n>0) ? min*2.0     : min
            set min_err = (sersic_n>0) ? min_err*2.0 : min_err
            set min_pix = (sersic_n>0) ? min_pix*2.0 : min_pix
        }
        # 
        #<below><added><20170606><dzliu>#
        set pix_scale = f*0.0 + pixscale
        set pix_area = pi/(4*ln(2)) * maj_pix*min_pix # or -- pi/4 * maj_pix*min_pix # in unit of pixel-sq.
        set beam_area = f*0.0 + beamarea # in unit of arcsec-sq.
        set source_area_in_pix = pix_area # in unit of pixel-sq.
        set source_area_in_arcsec = pi/(4*ln(2)) * maj*min # in unit of arcsec-sq.
        set source_area_in_beam = source_area_in_arcsec / beam_area # in unit of beamarea
        set convol_area_in_pix = sqrt((beam_area/(pix_scale*pix_scale))**2 + source_area_in_pix**2)
        #set convol_area_in_arcsec = sqrt(beam_area**2 + source_area_in_arcsec**2) #<BUGGY><20171223># convol_area is not the direct square root of the sum of squared two area. 
        #<20180309># --- 2D Gaussian size convolution
        #<20180309>#set convol_maj = sqrt(beam_maj**2 + maj**2) # arcsec #<TODO># two 2D Gaussian convolution
        #<20180309>#set convol_min = sqrt(beam_min**2 + min**2) # arcsec #<TODO># two 2D Gaussian convolution
        calc_convolved_sizes maj min pa beam_maj beam_min beam_pa
        set convol_maj = calcds_Maj_convol
        set convol_min = calcds_Min_convol
        set convol_pa = calcds_PA_convol
        #<20180309># --- 
        set convol_area_in_arcsec = pi/(4*ln(2)) * convol_maj * convol_min
        set convol_area_in_beam = convol_area_in_arcsec / beam_area
        set source_peak = f / convol_area_in_beam #<BUG><CORRECTED><20171123># dzliu, Yoshinobu, Philipp
        set source_total = f
        calc_Condon1997_errors 
        #<20171123># See Gaussian convolved sigma here -- http://www.tina-vision.net/docs/memos/2003-003.pdf -- Page 7 Top
        #set f_peak = f / pix_area # now this is the peak pixel flux with unit of Jy/pixel
        #set f_peak = f_peak / (pixscale**2) * beamarea
        #set f_peak_err = ResultFluxErr
        #set f_err = ResultFluxErr * sqrt(pi/(4*ln(2))*maj_pix*min_pix)
        set f_peak = ResultFluxPeak # original pixel unit, measured from source model image
        set f_resabs = ResultFluxResAbs # original pixel unit
        set f_reschisq = ResultFluxResChisq
        set f_redchisq = ResultFluxRedChisq
        set n_aperpix = ResultFluxNumPixel
        set n_freepar = ResultNumbFreeParam
        set f_origin = ResultFluxOrigin # the pixel value at the fitted position
        # 
        #<above><added><20170606><dzliu>#
        # 
        print $1.result '%12.4f %12.4f %14g %14g %14g %14g %10.4f %13g %10.4f %13g %10.4f %13g %10.4f %13g %12g %12g %12g %12g %15.0f %15s\n' \
            {x y f f_err f_peak f_resabs mag mag_err maj maj_err min min_err pa pa_err pix_scale pix_area beam_area pb_corr cat_index cat_id}
            #1.2.3.4.    5.     6.       7.  8.      9.  10.     11. 12.     13.14.    15.       16.      17.       18.     19.       20.   
        # 
        #<below><added><20170727><dzliu>#
        #if(sum(sersic_n>0)>0) {
        print $1.result.sersic_n.txt '%15g %15g %15.0f %15s\n' \
            {sersic_n sersic_n_err cat_index cat_id}
        #}
        #<above><added><20170727><dzliu>#
        # 
        # 
        #<below><added><20170923><dzliu>#
        print $1.result.chisq.txt '%25g %15g %15.3f %15d %15.0f %15s\n' \
            {f_reschisq f_redchisq n_aperpix n_freepar cat_index cat_id}
        #<above><added><20170923><dzliu>#
        # 
        # 
        #<below><added><20170923><dzliu>#
        print $1.result.source_area.txt '%25g %25g %25g %25g %25g %25g %15.0f %15s\n' \
            {source_area_in_pix source_area_in_arcsec source_area_in_beam convol_area_in_pix convol_area_in_arcsec convol_area_in_beam cat_index cat_id}
        #<above><added><20170923><dzliu>#
        # 
        # 
        #<below><added><20170923><dzliu>#
        print $1.result.source_err.txt '%25g %25g %25g %25g %25g %25g %25g %25g %25g %25g %25g %15.0f %15s\n' \
            {source_total source_total_err source_peak source_peak_err source_gaussian_snr maj source_major_err source_major_err_rel min source_minor_err source_minor_err_rel cat_index cat_id}
        #<above><added><20170923><dzliu>#
        # 
        # 
        #<below><added><20170923><dzliu>#
        print $1.result.flux_origin.txt '%25s %15.0f %15s\n' \
            {f_origin cat_index cat_id}
        #<above><added><20170923><dzliu># #<20180613># bug --> should read f_origin as str instead of float
        # 
        # 
        #<below><added><20171123><dzliu>#
        set _beam_maj = maj>0 ? beam_maj : beam_maj
        set _beam_min = min>0 ? beam_min : beam_min
        print $1.result.source_peak.txt '%25g %25g %25g %25g %25g %25g %25g %25g %25g %15.0f %15s\n' \
            {source_peak f_peak f maj min _beam_maj _beam_min convol_maj convol_min cat_index cat_id}
        unset _beam_maj
        unset _beam_min
        #<above><added><20171123><dzliu>#
        # 
        # 
        #<below><added><20170822><dzliu>#
        set buffer_x = 0
        set buffer_y = 0
        if(is_file("buffer_x_y.txt")) {
            data "buffer_x_y.txt" read {buffer_x 1 buffer_y 2}
        }
        if(is_file("buffer_size_limit.txt")) {
            #<added><20170923><dzliu>#
            data "buffer_size_limit.txt" read {buffer_size_limit 1}
            set buffer_x = (buffer_x<buffer_size_limit) ? buffer_size_limit : buffer_x
            set buffer_y = (buffer_y<buffer_size_limit) ? buffer_size_limit : buffer_y
        }
        !gethead "image_sci.fits" NAXIS1 NAXIS2 > "image_sci.fits.gethead.naxis.txt"
        verbose 0 data "image_sci.fits.gethead.naxis.txt" read {image_x 1 image_y 2} verbose 1
        set mask_buffer = (x<=buffer_x || x>(image_x-buffer_x) || y<=buffer_y || y>(image_y-buffer_y))
        print $1.result.mask_buffer.txt '%15g %15.0f %15s\n' {mask_buffer cat_index cat_id}
        #<above><added><20170822><dzliu>#
        # 
    }






print_result_final 01
    #<20170808># now allow input argument $1, if no input of $1, we print 'final' results, otherwise if has input of $1, we print 'final_on_negative_image' results. 
    if(!$?1) {
        set final_basename = 'final'
        set getpix_basename = 'getpix'
        set galfit_basenames = { fit_0 fit_1 fit_2 fit_3}
    } else { 
        set final_basename = 'final_on_negative_image'
        set getpix_basename = 'getpix_on_negative_image'
        set galfit_basenames = { fit_n0 fit_n1 fit_n2 fit_n3}
    }
    if(!is_file("No_catalog_source_within_image")) {
        if(is_file($(final_basename).result)) { !mv $(final_basename).result $(final_basename).result.backup }
        if(is_file($(final_basename).result.all.txt)) { !mv $(final_basename).result.all.txt $(final_basename).result.all.txt.backup }
        load wfile.sm
        calc_beamarea
        calc_fluxconv
        read_pixscale
        read_pixnoise
        set rms = pixnoise * fluxconv # (beamarea/(pixscale*pixscale)) # original pixel unit -> Jy (integrated over 1 pixel / TODO: OR the pixels corresponding to one beamarea?)
        # 
        # check whether Jy/beam, if so, convert rms to mJy/beam only if the original pixel unit is Jy/beam
        if(is_vector(fluxunit)) {
            if(fluxunit=='Jy/beam'||fluxunit=='JY/BEAM') {
                set rms = rms * 1e3
            }
        }
        # 
        # read sky_freq
        if(is_file("image_sci_sky_frequency.txt")) {
            data "image_sci_sky_frequency.txt" read { sky_freq 1.f }
        } else {
            set sky_freq = -99
        }
        data "prior_id.txt" read { cat_id_full 1.s }
        # 
        # read getpix
        data $(getpix_basename).txt read { x_getpix 5.f y_getpix 6.f }
        data $(getpix_basename).result read { f_peak 1 f_int 2 snr_peak 3 snr_int 4 cid_getpix 7 }
        set f_peak = f_peak * 1e3 # mJy
        set f_int = f_int * 1e3 # mJy
        define print_noheader 1
        print $(getpix_basename).xy2sky.input '%15.4f %15.4f\n' {x_getpix y_getpix}
        define print_noheader 0
        echo xy2sky -d -n 10 "image_sci.fits" @$(getpix_basename).xy2sky.input > $(getpix_basename).xy2sky.output
        !xy2sky -d -n 10 "image_sci.fits" @$(getpix_basename).xy2sky.input > $(getpix_basename).xy2sky.output
        data $(getpix_basename).xy2sky.output read {ra_getpix 1.f dec_getpix 2.f}
        set id_getpix = cat_id_full[cid_getpix]
        set det_getpix = int(snr_peak>=3.6 || snr_int>=2.0)
        set Nfit_getpix = int(dimen(cid_getpix))
        set Ndet_getpix = int(sum(det_getpix))
        #print $(getpix_basename).result.ra.dec.detect.id '%15.7f %15.7f %15d %15s\n' {ra_getpix dec_getpix det_getpix id_getpix}
        #echo "Output to \""$(getpix_basename)".result.ra.dec.detect.id\"!"
        # 
        # initialize galfit must output variable
        foreach var galfit_basenames { set Nfit_$var = 0 set Ndet_$var = 0 }
        # 
        # read galfit if not 'No_catalog_source_with_enough_getpix_SNR' #<fixed><20170822># affects negative fitting "*final*.result"
        if(final_basename!='final_on_negative_image') {
            set check_has_source_for_galfit = (!is_file("No_catalog_source_with_enough_getpix_SNR"))
        } else {
            set check_has_source_for_galfit = (!is_file("No_catalog_source_with_enough_getpix_SNR_on_negative_image"))
        }
        if(check_has_source_for_galfit) {
            foreach var galfit_basenames {
                # check $var.result, if it does not exist while $var.fits exists, then call 'print_result'
                if(!is_file($var.result) && is_file($var.fits)) {
                    load astroGalfit.sm
                    readGalfitResult $var.fits
                    if(final_basename!='final_on_negative_image') {
                        print_result $var
                    } else {
                        print_result $var "getpix_on_negative_image.mask"
                    }
                }
                # read $var.result and other data, print into big datatables
                define has_$var 1
                if(!is_file($var.pb_corr.txt))            { print 'Error! Could not find \"$var.pb_corr.txt\"\n' {}             define has_$var 0 }
                if(!is_file($var.result))                 { print 'Error! Could not find \"$var.result\"\n' {}                  define has_$var 0 }
                if(!is_file($var.result.sersic_n.txt))    { print 'Error! Could not find \"$var.result.sersic_n.txt\"\n' {}     define has_$var 0 }
                if(!is_file($var.result.chisq.txt))       { print 'Error! Could not find \"$var.result.chisq.txt\"\n' {}        define has_$var 0 }
                if(!is_file($var.result.source_area.txt)) { print 'Error! Could not find \"$var.result.source_area.txt\"\n' {}  define has_$var 0 }
                if(!is_file($var.result.mask_buffer.txt)) { print 'Error! Could not find \"$var.result.mask_buffer.txt\"\n' {}  define has_$var 0 }
                if($has_$var) {
                    data $var.pb_corr.txt             read {pbcorr 1.f pb_corr 2.f} # pbcorr is from pb image, pb_corr is from mathematics
                    data $var.result.sersic_n.txt     read {sersic_n 1.f sersic_n_err 2.f}
                    data $var.result.chisq.txt        read {chisq 1.f rchisq 2.f n_aperpix 3.f n_freepar 4.f}
                    data $var.result.source_area.txt  read {convol_area_in_pix 4.f convol_area_in_arcsec 5.f convol_area_in_beam 6.f}
                    data $var.result.mask_buffer.txt  read {flag_buffer 1.f}
                    data $var.result
                    read < x_$var 1.f y_$var 2.f f_$var 3.f df_$var 4.f fpeak_$var 5.f fres_$var 6.f cid_$var 19 > #<TODO># make sure cat_index column number is correct
                    read < Maj_$var 9.f Maj_err_$var 10.f Min_$var 11.f Min_err_$var 12.f PA_$var 13.f PA_err_$var 14.f > #<20170514><dzliu># Maj Min are already arcsec unit
                    read < pix_scale 15.f pix_area 16.f beam_area 17.f > #<20170606><dzliu># for fpeak ftotal
                    # Jy -> mJy
                    # convert to mJy/beam if the fluxunit is Jy/beam, otherwise do not do conversion
                    if(is_vector(fluxunit)) {
                        if(fluxunit=='Jy/beam'||fluxunit=='JY/BEAM') {
                            foreach bar { f df fpeak fres } { set $bar"_"$var = ($bar"_"$var!=-99) ? $bar"_"$var * 1e3 : -99 }
                        }
                    }
                    # xy2sky
                    define print_noheader 1
                    print $var.xy2sky.input '%15.4f %15.4f\n' <x_$var y_$var>
                    echo xy2sky -d -n 10 "image_sci.fits" @$var.xy2sky.input > $var.xy2sky.output
                    !xy2sky -d -n 10 "image_sci.fits" @$var.xy2sky.input > $var.xy2sky.output
                    data $var.xy2sky.output read <ra_$var 1.f dec_$var 2.f>
                    define print_noheader 0
                    # catalog id
                    set id_$var = cat_id_full[cid_$var]
                    # obs freq
                    set obs_freq = f_$var*0.0 + sky_freq # GHz
                    set obs_lambda = (obs_freq>0) ? 2.99792458e5 / obs_freq : -99 # um
                    # pix_noise
                    set pix_noise = f_$var*0.0 + pixnoise
                    # flux_conv
                    set flux_conv = f_$var*0.0 + fluxconv
                    # rms
                    set rms_$var = f_$var*0.0 + rms * sqrt(convol_area_in_pix) #<20170923># rms over multiple pixels # mJy if the original flux unit is Jy/beam, otherwise original flux unit. 
                    # snr
                    set df_tmp = (df_$var<=0) ? 1e-99 : df_$var
                    set snr_$var = (df_$var>rms_$var) ? (f_$var/df_tmp) : (f_$var/rms_$var)
                    # detection
                    set det_$var = int(snr_$var>=3.0)
                    # Nfit and Ndet
                    set Nfit_$var = int(dimen(cid_$var))
                    set Ndet_$var = int(sum(det_$var))
                    # print
                    #print $var.result.ra.dec.detect.id '%15.7f %15.7f %15d %15s\n' <ra_$var dec_$var det_$var id_$var>
                    #echo "Output to \""$var".result.ra.dec.detect.id\"!"
                    #print $var.result.ra.dec.f.df.snr.id '%15.7f %15.7f %15g %15g %15g %15s\n' <ra_$var dec_$var f_$var df_$var snr_$var id_$var>
                    #echo "Output to \""$var".result.ra.dec.f.df.snr.id\"!"
                    # print morphological measurements
                    #print $var.result.ra.dec.Maj.Min.PA.id '%15.7f %15.7f %15g %15g %15g %15g %15g %15g %15s\n' \
                    #      <ra_$var dec_$var Maj_$var Maj_err_$var Min_$var Min_err_$var PA_$var PA_err_$var id_$var> #<20170514><dzliu>#
                    # print photometric measurements
                    #print $var.result.ra.dec.rms.pix.pbc.id '%15.7f %15.7f %15g %15g %15g %15g %15g %15g %15g %15g %15g %15g %15g %15g %15s\n' \
                    #      <ra_$var dec_$var f_$var df_$var fpeak_$var fres_$var rms_$var snr_$var pix_scale pix_area beam_area pb_corr obs_freq obs_lambda id_$var> #<20170606><dzliu>#
                    # print big output file <20170923>
                    set id_$var""_str = id_$var
                    set source_area = convol_area_in_beam
                    set wfile_vectors = <ra_$var dec_$var f_$var df_$var fpeak_$var fres_$var rms_$var snr_$var Maj_$var Maj_err_$var Min_$var Min_err_$var PA_$var PA_err_$var source_area>
                    set wfile_vectors = wfile_vectors concat {pix_noise pix_scale beam_area pbcorr pb_corr flux_conv obs_freq obs_lambda}
                    set wfile_vectors = wfile_vectors concat {sersic_n sersic_n_err chisq rchisq n_aperpix n_freepar flag_buffer}
                    set wfile_vectors = wfile_vectors concat 'cid_$var'
                    set wfile_vectors = wfile_vectors concat 'id_$var""_str'
                    wfile $var.result.all.txt
                    # print message
                    #echo "Output to \""$var".result.ra.dec.Maj.Min.PA.id\"!"
                    #echo "Output to \""$var".result.ra.dec.rms.pix.pbc.id\"!"
                    echo "Output to \""$var".result.all.txt\"!"
                }
            }
        }
        # 
        define pcol_1  Nfit_getpix
        define pcol_2  Ndet_getpix
        define pcol_3  Nfit_$(galfit_basenames[0])
        define pcol_4  Ndet_$(galfit_basenames[0])
        define pcol_5  Nfit_$(galfit_basenames[1])
        define pcol_6  Ndet_$(galfit_basenames[1])
        define pcol_7  Nfit_$(galfit_basenames[2])
        define pcol_8  Ndet_$(galfit_basenames[2])
        define pcol_9  Nfit_$(galfit_basenames[3])
        define pcol_10 Ndet_$(galfit_basenames[3])
        print $(final_basename).result '%15d %15d %15d %15d %15d %15d %15d %15d %15d %15d\n' \
            < $pcol_1 $pcol_2 $pcol_3 $pcol_4 $pcol_5 $pcol_6 $pcol_7 $pcol_8 $pcol_9 $pcol_10 >
        # 
    } else {
        # if no catalog source within image, then remove any existing $(final_basename).result
        if(is_file($(final_basename).result)) { !mv $(final_basename).result $(final_basename).result.backup }
    }


print_result_final_on_negative_image 00
    print_result_final _on_negative_image















go_fix_bug_20171221
    # bug: "mask_prior_sources_on_negative_image"
    #      The negative image fitting used original "getpix.mask"! It should used "getpix_on_negative_image.mask"!
    # fix: first re-run "mask_prior_sources"
    #      then re-run "print_result_final"
    #      then re-run negative image fitting
    !cp fit_0.pbcorr.txt                fit_0.pb_corr_from_calc.txt
    !cp fit_0.pbcorr.from.pb.image.txt  fit_0.pb_corr_from_pb_image.txt
    !cp fit_0.result.pbc.txt            fit_0.pb_corr.txt
    !cp fit_1.pbcorr.txt                fit_1.pb_corr_from_calc.txt
    !cp fit_1.pbcorr.from.pb.image.txt  fit_1.pb_corr_from_pb_image.txt
    !cp fit_1.result.pbc.txt            fit_1.pb_corr.txt
    !cp fit_2.pbcorr.txt                fit_2.pb_corr_from_calc.txt
    !cp fit_2.pbcorr.from.pb.image.txt  fit_2.pb_corr_from_pb_image.txt
    !cp fit_2.result.pbc.txt            fit_2.pb_corr.txt
    !cp fit_3.pbcorr.txt                fit_3.pb_corr_from_calc.txt
    !cp fit_3.pbcorr.from.pb.image.txt  fit_3.pb_corr_from_pb_image.txt
    !cp fit_3.result.pbc.txt            fit_3.pb_corr.txt
    #--> now renamed pb_corr files
    # 
    read_data
    read_pixscale
    read_pixnoise
    calc_fluxconv
    mask_prior_sources
    print_result_final
    #--> this will rewrite "$input_file.mask"
    # 
    read_data
    read_pixscale
    read_pixnoise
    calc_fluxconv
    mask_prior_sources_on_negative_image
    go_galfit_n0
    go_galfit_n1
    go_galfit_n2
    go_galfit_n3
    print_result_final_on_negative_image
    #--> this will rewrite "getpix_on_negative_image.mask"
















