#!/bin/bash
# 
# 
# This code will measure line according to predicted line name, observing frequency and source RA, Dec, redshift. 
# We will automatically smooth the uvtable data to a velocity resolution of about 10 km/s. 
# 
# The input of this code is a prior catalog with ID, RA, Dec, z, 
# 
# We will search for meta data 
# 

# 
# usage
function usage() {
    echo "# Aim: "
    echo "#        This code is a pipeline of a3cosmos for extracting spectrum at a prior position, and measure line fluxes if line names and source redshifts are given in the input catalog."
    echo "# "
    echo "# Usage: a3cosmos-prior-extraction-spectroscopy \\"
    echo "#                                               -catalog input_catalog.txt \\"
    echo "#                                               -begin 1 -end 10 \\"
    echo "#                                               -overwrite -overwrite -overwrite"
    echo "# "
    echo "# Notes: "
    echo "#      - The input catalog should be a text file with at least the following 3 columns: ID, RA, Dec."
    echo "#        If available the code will read next 4 columns as: z, LineName, LineFreq, LineFWZI."
    echo "#        Columns should be separated by white spaces."
    echo "#      - One '-overwrite' will overwrite spectrum plots, two will overwrite uvfit tables, three will overwrite line map averaging data, four will re-copy uvt data, five will re-query alma meta table."
}

# 
# Check GILDAS
if [[ $(type mapping 2>/dev/null | wc -l) -eq 0 ]]; then
    if [[ -f "$HOME/Softwares/GILDAS/SETUP.bash" ]]; then
        source "$HOME/Softwares/GILDAS/SETUP.bash"
    else
        echo "Error! GILDAS/mapping has not been installed yet?!"; exit 1
    fi
fi

# 
# Check Crab.Toolkit.PdBI
if [[ $(type pdbi-uvt-go-uvfit 2>/dev/null | wc -l) -eq 0 ]]; then
    if [[ -f "$HOME/Cloud/Github/Crab.Toolkit.PdBI/SETUP.bash" ]]; then
        source "$HOME/Cloud/Github/Crab.Toolkit.PdBI/SETUP.bash"
    else
        echo "Error! Crab.Toolkit.PdBI has not been downloaded and sourced yet?! Please download it from https://github.com/1054/Crab.Toolkit.PdBI and source the SETUP.bash file therein, then all the tools will be able to use."; exit 1
    fi
fi

# 
# Check a3cosmos-query-alma-data-by-radec.py
if [[ $(type a3cosmos-query-alma-data-by-radec.py 2>/dev/null | wc -l) -eq 0 ]]; then
    if [[ -f "$(dirname $(dirname ${BASH_SOURCE[0]}))/SETUP.bash" ]]; then
        source "$(dirname $(dirname ${BASH_SOURCE[0]}))/SETUP.bash"
    else
        echo "Error! $(dirname $(dirname ${BASH_SOURCE[0]}))/SETUP.bash was not found?! The package from https://github.com/1054/a3cosmos-prior-extraction is incomplete!"; exit 1
    fi
fi

# 
# Read user input
input_cat=()
uvt_dir="aida40110:/disk1/dzliu/Works/AlmaCosmos/Spectroscopy/Level_3_ms/uvt"
begin_id=1
end_id=0
overwrite=0
CAAP_CMD_TEXT=""
CAAP_CMD_TYPE=""
while [[ "$#" -gt 0 ]]; do
    #echo $1
    TempStr=$(echo "$1" | tr '[:upper:]' '[:lower:]')
    #echo $TempStr
    case "$TempStr" in
                                            "-cat") CAAP_CMD_TEXT="$1"; shift; CAAP_CMD_TYPE="input_cat";;
                                        "-catalog") CAAP_CMD_TEXT="$1"; shift; CAAP_CMD_TYPE="input_cat";;
                                            "-uvt") CAAP_CMD_TEXT="$1"; shift; CAAP_CMD_TYPE="uvt_dir";;
                                        "-uvt-dir") CAAP_CMD_TEXT="$1"; shift; CAAP_CMD_TYPE="uvt_dir";;
                                          "-begin") CAAP_CMD_TEXT="$1"; shift; CAAP_CMD_TYPE="begin_id";;
                                            "-end") CAAP_CMD_TEXT="$1"; shift; CAAP_CMD_TYPE="end_id";;
                                      "-overwrite") CAAP_CMD_TEXT="$1";        CAAP_CMD_TYPE="overwrite";;
    esac
    #echo "$CAAP_CMD_TYPE"
    case "$CAAP_CMD_TYPE" in
                                       "input_cat") if [[ $# -gt 0 ]]; then input_cat+=("$1"); fi;;
                                         "uvt_dir") if [[ $# -gt 0 ]]; then uvt_dir="$1"; fi;;
                                        "begin_id") if [[ $# -gt 0 ]]; then begin_id="$1"; fi;;
                                          "end_id") if [[ $# -gt 0 ]]; then end_id="$1"; fi;;
                                       "overwrite")                         overwrite=$((overwrite+1));;
    esac
    #
    if [[ $# -gt 0 ]]; then shift; fi
done


# 
# Check user input
if [[ ${#input_cat[@]} -eq 0 ]]; then
    usage
    exit 1
fi


# 
# Create working directory
if [[ ! -d "a3cosmos_prior_extraction_spectroscopy_working_dir" ]]; then
    mkdir "a3cosmos_prior_extraction_spectroscopy_working_dir"
fi


# 
# read the input table
input_candidate_table="${input_cat[0]}"
list_of_cols=($(cat "$input_candidate_table" | grep '^#' | head -n 1 | sed -e 's/^# *//g' | tr -s ' ')) # read first commented line as the header line.
if [[ ${#list_of_cols[@]} -eq 0 ]]; then 
    list_of_cols=()
    list_of_cells=($(cat "$input_candidate_table" | grep -v '^#' | head -n 1 | sed -e 's/^ *//g' | tr -s ' ')) # if failed, then read the first uncommented line as the header line.
    for (( i = 1; i <= ${#list_of_cells[@]}; i++ )); do
        list_of_cols+=("col$i")
    done
fi
echo "Reading the input catalog: \"input_candidate_table\""
echo "Input catalog header: (${#list_of_cols[@]}) ${list_of_cols[@]}"
if [[ ${#list_of_cols[@]} -ge 3 ]]; then
    list_of_IDs=($(cat "$input_candidate_table" | grep -v '^#' | sed -e 's/^ *//g' | tr -s ' ' | cut -d ' ' -f 1))
    list_of_RAs=($(cat "$input_candidate_table" | grep -v '^#' | sed -e 's/^ *//g' | tr -s ' ' | cut -d ' ' -f 2))
    list_of_Decs=($(cat "$input_candidate_table" | grep -v '^#' | sed -e 's/^ *//g' | tr -s ' ' | cut -d ' ' -f 3))
else
    echo "Error! The input catalog does not have enough columns to read!"; exit 255
fi
if [[ ${#list_of_cols[@]} -ge 4 ]]; then
    list_of_zs=($(cat "$input_candidate_table" | grep -v '^#' | sed -e 's/^ *//g' | tr -s ' ' | cut -d ' ' -f 4))
else
    for (( i = 0; i < ${#list_of_IDs[@]}; i++ )); do list_of_zs+=("-99"); done
fi
if [[ ${#list_of_cols[@]} -ge 5 ]]; then
    list_of_LineNames=($(cat "$input_candidate_table" | grep -v '^#' | sed -e 's/^ *//g' | tr -s ' ' | cut -d ' ' -f 5))
else
    for (( i = 0; i < ${#list_of_IDs[@]}; i++ )); do list_of_LineNames+=(""); done
fi
if [[ ${#list_of_cols[@]} -ge 6 ]]; then
    list_of_LineFreqs=($(cat "$input_candidate_table" | grep -v '^#' | sed -e 's/^ *//g' | tr -s ' ' | cut -d ' ' -f 6))
else
    for (( i = 0; i < ${#list_of_IDs[@]}; i++ )); do list_of_LineFreqs+=("-99"); done
fi
if [[ ${#list_of_cols[@]} -ge 7 ]]; then
    list_of_LineFWZIs=($(cat "$input_candidate_table" | grep -v '^#' | sed -e 's/^ *//g' | tr -s ' ' | cut -d ' ' -f 7))
else
    for (( i = 0; i < ${#list_of_IDs[@]}; i++ )); do list_of_LineFWZIs+=("-99"); done
fi
#if [[ ${#list_of_cols[@]} -ge 8 ]]; then
#    list_of_LineFluxs=($(cat "$input_candidate_table" | grep -v '^#' | sed -e 's/^ *//g' | tr -s ' ' | cut -d ' ' -f 8))
#else
#    for (( i = 0; i < ${#list_of_IDs[@]}; i++ )); do list_of_LineFWZIs+=("0.0"); done
#fi
#if [[ ${#list_of_cols[@]} -ge 8 ]]; then
#    list_of_ImageNames=($(cat "$input_candidate_table" | grep -v '^#' | sed -e 's/^ *//g' | tr -s ' ' | cut -d ' ' -f 9))
#else
#    for (( i = 0; i < ${#list_of_IDs[@]}; i++ )); do list_of_ImageNames+=("N/A"); done
#fi


# 
# cd working dir
cd "a3cosmos_prior_extraction_spectroscopy_working_dir"
echo "Current directory: $(pwd)"
echo "--------"
echo "--------"
echo "Start looping ${#list_of_IDs[@]} prior sources!!"
if [[ $begin_id -gt 0 ]]; then begin_id=$begin_id; else begin_id=1; fi
if [[ $end_id -ge $begin_id ]]; then end_id=$end_id; else end_id=${#list_of_IDs[@]}; fi
echo "Begin with ID $begin_id"
echo "Will end with ID $end_id"
echo "--------"
echo "--------"

# 
# Loop the input prior source list
debug_only_one_candidate=0
debug_since_candidate_id=1
for (( i = $((begin_id-1)); i < $end_id; i++ )); do
    # 
    # get info
    candidate_ID=${list_of_IDs[i]}
    candidate_RA=${list_of_RAs[i]}
    candidate_Dec=${list_of_Decs[i]}
    candidate_z=${list_of_zs[i]}
    candidate_line_name="${list_of_LineNames[i]}"
    candidate_line_freq="${list_of_LineFreqs[i]}" # predicted line center frequency in units of GHz
    candidate_line_fwzi=${list_of_LineFWZIs[i]} # in default 500 km/s line full width at zero intensity (FWZI)
    # 
    # mkdir subfolder
    #candidate_dir="candidate_$((i+1))"
    candidate_dir="ID_$candidate_ID"
    if [[ ! -d "$candidate_dir" ]]; then
        mkdir "$candidate_dir"
    fi
    echo ""
    echo "cd \"$(pwd)/$candidate_dir\""
    cd "$candidate_dir"
    # 
    if [[ -f "candidate_info.txt" ]]; then
        mv "candidate_info.txt" "candidate_info.txt.backup"
    fi
    if [[ ! -f "candidate_info.txt" ]]; then
        echo "input_candidate_table = \"$input_candidate_table\"" > "candidate_info.txt"
        echo "i = ${i}" >> "candidate_info.txt"
        echo "pwd = \"$candidate_dir\"" >> "candidate_info.txt"
        echo "candidate_ID = ${candidate_ID}" >> "candidate_info.txt"
        echo "candidate_RA = ${candidate_RA}" >> "candidate_info.txt"
        echo "candidate_Dec = ${candidate_Dec}" >> "candidate_info.txt"
        echo "candidate_z = ${candidate_z}" >> "candidate_info.txt"
        echo "candidate_line_name = \"${candidate_line_name}\"" >> "candidate_info.txt"
        echo "candidate_line_freq = ${candidate_line_freq}" >> "candidate_info.txt"
        echo "candidate_line_fwzi = ${candidate_line_fwzi}" >> "candidate_info.txt"
    fi
    # 
    if [[ ! -f "queried_alma_data.txt" ]] || [[ $overwrite -ge 5 ]]; then
        echo "a3cosmos-query-alma-data-by-radec.py $candidate_RA $candidate_Dec"
        a3cosmos-query-alma-data-by-radec.py $candidate_RA $candidate_Dec -radius 15.0 > "queried_alma_data.txt"
        if [[ -d "run_uvfit" ]]; then
            if [[ -d "run_uvfit.backup" ]]; then
                rm -rf "run_uvfit.backup"
            fi
            mv "run_uvfit" "run_uvfit.backup"
        fi
    else
        echo "Using existing quried table \"queried_alma_data.txt\". To overwrite it please input five '-overwrite'."
    fi
    # 
    IFS=$'\n' image_names=($(cat "queried_alma_data.txt" | grep '^image_name' | perl -p -e 's/^[^=]+ *= *(.*)$/\1/g' | tr -s ' ' | perl -p -e 's/^ *(.*?) *$/\1/g'))
    IFS=$'\n' source_names=($(cat "queried_alma_data.txt" | grep '^source' | perl -p -e 's/^[^=]+ *= *(.*)$/\1/g' | tr -s ' ' | perl -p -e 's/^ *(.*?) *$/\1/g'))
    IFS=$'\n' freq_supports=($(cat "queried_alma_data.txt" | grep '^freq_support' | perl -p -e 's/^[^=]+ *= *(.*)$/\1/g' | sed -e 's/[^0-9.+-]/ /g' | tr -s ' ' | perl -p -e 's/^ *(.*?) *$/\"\1\"/g'))
    echo "candidate_line_name = ${candidate_line_name}"
    echo "candidate_line_freq = ${candidate_line_freq}"
    echo "candidate_line_fwzi = ${candidate_line_fwzi}"
    echo "candidate_ID = ${candidate_ID}"
    echo "candidate_RA = ${candidate_RA}"
    echo "candidate_Dec = ${candidate_Dec}"
    echo "candidate_z = ${candidate_z}"
    echo "image_names = (${#image_names[@]}) ${image_names[@]}"
    echo "source_names = (${#source_names[@]}) ${source_names[@]}"
    echo "freq_supports = (${#freq_supports[@]}) ${freq_supports[@]}"
    # 
    # do uvfit
    if [[ ! -d "run_uvfit" ]]; then
        mkdir "run_uvfit"
    fi
    # 
    # cd "run_uvfit"
    echo "cd \"$(pwd)/run_uvfit\""
    cd "run_uvfit"
    #
    # loop the queried alma data list and find the uvt files and extract spectrum at the prior RA Dec position
    for (( j = 0; j < ${#image_names[@]}; j++ )); do
        # 
        # check if the uvt data files are already prepared or not
        kds=$((j+1)) # k index of current dataset
        kdc=0 # k index of matched datacube
        if [[ ! -f "dataset_${kds}_datacube_list.txt" ]] || [[ $overwrite -ge 4 ]]; then
            # 
            # To find the uvt files, we need to look into our uvt data directory
            obj_name_pattern=$(echo ${source_names[j]} | perl -p -e 's/\"(.*)\"/\1/g' | perl -p -e 's/^_*(.*?)_*$/\1/g') # remove quotes, remove leading and trailing underscores
            echo "obj_name_pattern = $obj_name_pattern"
            # 
            #IFS=' ' t_freq_support=($(echo ${freq_supports[j]} | perl -p -e 's/\"(.*)\"/\1/g')) # this should be all spws. each spw has two freq values. 
            #echo "t_freq_support = (${#t_freq_support[@]}) ${t_freq_support[@]}"
            # 
            uvt_name_pattern=$(echo ${image_names[j]} | perl -p -e 's/^[\"]*(.+?)_SB_([^_]+?)_GB_([^_]+?)_MB_([^_]+?)_.*[\"]*/\1_SB_\2_GB_\3_MB_\4/g')
            echo "uvt_name_pattern = $uvt_name_pattern"
            # 
            uvt_spw_pattern="*" #<TODO># for now we do not match frequency support to find a typical spw
            echo "uvt_spw_pattern = $uvt_spw_pattern"
            # 
            # try to find the uvt file
            if [[ x"$uvt_dir" == x*":"* ]]; then
                remote_host=$(echo "$uvt_dir" | cut -d ':' -f 1)
                remote_dir=$(echo "$uvt_dir" | cut -d ':' -f 2)
                echo "ssh -t $remote_host \"find \\\"$remote_dir\\\" -type d -name \\\"${uvt_name_pattern}*\\\"\""
                IFS=$'\n' matched_data_dirs=($(ssh -t $remote_host "find \"$remote_dir\" -type d -name \"${uvt_name_pattern}*\"" 2>/dev/null | tr -c '[[:print:]]' '\n')) # sed 's/[^[:print:]]+/\n/g' not working, only tr -c works
            else
                echo "find \"${uvt_dir}\" -type d -name \"${uvt_name_pattern}*\""
                IFS=$'\n' matched_data_dirs=($(find "${uvt_dir}" -type d -name "${uvt_name_pattern}*"))
            fi
            if [[ ${#matched_data_dirs[@]} -eq 0 ]]; then
                echo "Error! Failed to find \"${uvt_dir}/${uvt_name_pattern}*\"!"
                exit 255
            fi
            if [[ ${#matched_data_dirs[@]} -eq 1 ]]; then
                matched_data_dir=${matched_data_dirs[0]}
                echo "Found \"${matched_data_dir}\"!"
                if [[ x"$uvt_dir" == x*":"* ]]; then
                    remote_host=$(echo "$uvt_dir" | cut -d ':' -f 1)
                    remote_dir=$(echo "$uvt_dir" | cut -d ':' -f 2)
                    echo "ssh -t $remote_host \"find \\\"${matched_data_dir}\\\" -type f -name \\\"split_${obj_name_pattern}_spw${uvt_spw_pattern}_width1_SP.uvt\\\"\""
                    IFS=$'\n' matched_data_files=($(ssh -t $remote_host "find \"${matched_data_dir}\" -type f -name \"split_${obj_name_pattern}_spw${uvt_spw_pattern}_width1_SP.uvt\"" 2>/dev/null | tr -c '[[:print:]]' '\n'))
                else
                    echo "find \"${matched_data_dir}\" -type f -name \"split_${obj_name_pattern}_spw${uvt_spw_pattern}_width1_SP.uvt\""
                    IFS=$'\n' matched_data_files=($(find "${matched_data_dir}" -type f -name "split_${obj_name_pattern}_spw${uvt_spw_pattern}_width1_SP.uvt"))
                fi
                #if [[ ${#matched_data_files[@]} -ge 2 ]]; then
                #    echo "Error! Found multiple \"${matched_data_dir}/split_${obj_name_pattern}_spw${uvt_spw_pattern}_width1_SP.uvt\"?!"
                #    exit 255
                #fi
                if [[ ${#matched_data_files[@]} -eq 0 ]]; then
                    matched_data_files=()
                    echo "Warning! Failed to find \"${matched_data_dir}/split_${obj_name_pattern}_spw${uvt_spw_pattern}_width1_SP.uvt\"!"
                    echo "We will try to find \"${matched_data_dir}/split_${obj_name_pattern}_spw${uvt_spw_pattern}_*.uvt\" and match by RA Dec!"
                    if [[ x"$uvt_dir" == x*":"* ]]; then
                        remote_host=$(echo "$uvt_dir" | cut -d ':' -f 1)
                        remote_dir=$(echo "$uvt_dir" | cut -d ':' -f 2)
                        echo "ssh -t $remote_host \"find \\\"${matched_data_dir}\\\" -type f -name \\\"split_*_spw${uvt_spw_pattern}_*.uvt\\\"\""
                        IFS=$'\n' matched_data_files+=($(ssh -t $remote_host "find \"${matched_data_dir}\" -type f -name \"split_*_spw${uvt_spw_pattern}_*.uvt\"" 2>/dev/null | tr -c '[[:print:]]' '\n'))
                    else
                        echo "find \"${matched_data_dir}\" -type f -name \"split_*_spw${uvt_spw_pattern}_*.uvt\""
                        IFS=$'\n' matched_data_files+=($(find "${matched_data_dir}" -type f -name "split_*_spw${uvt_spw_pattern}_*.uvt"))
                    fi
                fi
            else
                echo "Warning! Found multiple \"${uvt_dir}/${uvt_name_pattern}*\"! We will find all uvt files in each of these folders and match by RA Dec!"
                matched_data_files=()
                for (( kk = 0; kk < ${#matched_data_dirs[@]}; kk++ )); do
                    matched_data_dir=${matched_data_dirs[kk]}
                    echo "Looping \"${matched_data_dir}\" ($((kk+1))/${#matched_data_dirs[@]})!"
                    if [[ x"$uvt_dir" == x*":"* ]]; then
                        remote_host=$(echo "$uvt_dir" | cut -d ':' -f 1)
                        remote_dir=$(echo "$uvt_dir" | cut -d ':' -f 2)
                        echo ssh -t $remote_host "find \"${matched_data_dir}\" -type f -name \"split_*_spw${uvt_spw_pattern}_*.uvt\""
                        IFS=$'\n' matched_data_files+=($(ssh -t $remote_host "find \"${matched_data_dir}\" -type f -name \"split_*_spw${uvt_spw_pattern}_*.uvt\""))
                    else
                        echo find "${matched_data_dir}" -type f -name "split_*_spw${uvt_spw_pattern}_*.uvt"
                        IFS=$'\n' matched_data_files+=($(find "${matched_data_dir}" -type f -name "split_*_spw${uvt_spw_pattern}_*.uvt"))
                    fi
                done
            fi
            # 
            # if we have more than one matched_data_file in ${matched_data_files[@]}, then match by RA Dec
            if [[ ${#matched_data_files[@]} -gt 1 ]]; then
                echo "We found multiple uvt files! We will read uvt file header and find the right ones by RA Dec ..."
                #echo "${matched_data_files[@]}"
                temp_data_files=()
                for (( kkk = 0; kkk < ${#matched_data_files[@]}; kkk++ )); do
                    temp_data_files+=("${matched_data_files[kkk]}")
                done
                echo "temp_data_files = (${#temp_data_files[@]}) ${temp_data_files[@]}"
                matched_data_files=()
                matched_offset=0.0
                for (( kkk = 0; kkk < ${#temp_data_files[@]}; kkk++ )); do
                    temp_data_file=${temp_data_files[kkk]}
                    if [[ x"$uvt_dir" == x*":"* ]]; then
                        remote_host=$(echo "$uvt_dir" | cut -d ':' -f 1)
                        remote_dir=$(echo "$uvt_dir" | cut -d ':' -f 2)
                        scp "$remote_host:$temp_data_file" "temp_data_file.uvt"
                    else
                        echo "ln -fsT $temp_data_file temp_data_file.uvt"
                        ln -fsT $temp_data_file temp_data_file.uvt
                    fi
                    #ls -al temp_data_file.uvt
                    #echo "header temp_data_file.uvt" | mapping -nw -nl | grep '^Axis 0 *A0' | perl -p -e 's/^Axis 0 *A0 *([^ ]+?) *Axis 0 *D0 *([^ ]+?) *$/\1 \2/g'
                    IFS=' ' temp_radec_str=($(echo "header temp_data_file.uvt" | mapping -nw -nl | grep '^Axis 0 *A0' | perl -p -e 's/^Axis 0 *A0 *([^ ]+?) *Axis 0 *D0 *([^ ]+?) *$/\1 \2/g'))
                    if [[ ${#temp_radec_str[@]} -ne 2 ]]; then
                        echo "Error! Failed to read RA and Dec from the header of \"$(pwd)/$temp_data_file\" with GILDAS/mapping!"
                        exit 255
                    fi
                    temp_radec_deg=($(radec2degree ${temp_radec_str[@]}))
                    if [[ ${#temp_radec_deg[@]} -ne 2 ]]; then
                        echo "Error! Failed to convert RA Dec ${temp_radec_str[@]} to degrees with the Crab.Toolkit.PdBI/bin/radec2degree code!"
                        exit 255
                    fi
                    temp_ra=${temp_radec_deg[0]}
                    temp_dec=${temp_radec_deg[1]}
                    temp_offset=$(awk "BEGIN {print sqrt( ((($temp_ra)-($candidate_RA))*cos($candidate_Dec/180.0*3.1415926))**2 + (($temp_dec)-($candidate_Dec))**2 ) * 3600.0;}")
                    limit_offset=15.0
                    if [[ $(awk "BEGIN {if($temp_offset < $limit_offset) print 1; else print 0;}") -eq 1 ]]; then
                        matched_data_files+=("$temp_data_file")
                        matched_offset=$temp_offset
                        echo "temp_radec = $temp_ra $temp_dec, temp_offset = $temp_offset arcsec, temp_data_file = ${temp_data_file}"
                    else
                        echo "temp_radec = $temp_ra $temp_dec, temp_offset = $temp_offset arcsec (too large)"
                    fi
                    rm "temp_data_file.uvt"
                done
            fi
            if [[ ${#matched_data_files[@]} -eq 0 ]]; then
                echo "Error! Failed to find \"${matched_data_dir}/split_${obj_name_pattern}_spw${uvt_spw_pattern}_width1_SP.uvt\""
                echo "or \"${matched_data_dir}/split_*_spw${uvt_spw_pattern}_width1_SP.uvt\"! Continue to look for next spw!"
                #exit 255
                continue
            fi
            # 
            # loop each uvt file and copy to working dir
            echo "--------"
            echo "Looping ${#matched_data_files[@]} uvt file(s) and copying to working dir"
            echo "--------"
            for (( k = 0; k < ${#matched_data_files[@]}; k++ )); do
                # 
                matched_data_file=${matched_data_files[k]}
                # 
                kdc=$((k+1))
                # 
                kname="dataset_${kds}_datacube_${kdc}"
                # 
                if [[ x"$uvt_dir" == x*":"* ]]; then
                    remote_host=$(echo "$uvt_dir" | cut -d ':' -f 1)
                    remote_dir=$(echo "$uvt_dir" | cut -d ':' -f 2)
                    echo "scp \"$remote_host:$matched_data_file\" \"$kname.uvt\""
                    scp "$remote_host:$matched_data_file" "$kname.uvt"
                    echo "Copied into workding dir as \"$(pwd)/$kname.uvt\""
                    # store into datacube list file
                    printf "%30s %6s %s\n" "$kname" " " "$remote_host:$matched_data_file" >> "dataset_${kds}_datacube_list.txt"
                else
                    echo "ln -fsT \"$matched_data_file\" \"$kname.uvt\""
                    ln -fsT "$matched_data_file" "$kname.uvt"
                    echo "Linked into workding dir as \"$(pwd)/$kname.uvt\""
                    # store into datacube list file
                    printf "%30s %6s %s\n" "$kname" " " "$matched_data_file" >> "dataset_${kds}_datacube_list.txt"
                fi
                # 
                echo "input_candidate_table = \"$input_candidate_table\"" > $kname.readme.txt
                echo "i = $i" >> $kname.readme.txt
                echo "candidate_line_name = $candidate_line_name" >> $kname.readme.txt
                echo "candidate_line_freq = $candidate_line_freq" >> $kname.readme.txt
                echo "candidate_line_fwzi = $candidate_line_fwzi" >> $kname.readme.txt
                echo "candidate_ID = $candidate_ID" >> $kname.readme.txt
                echo "candidate_RA = $candidate_RA" >> $kname.readme.txt
                echo "candidate_Dec = $candidate_Dec" >> $kname.readme.txt
                echo "candidate_z = $candidate_z" >> $kname.readme.txt
                echo "" >> $kname.readme.txt
                echo "dataset = $kds" >> $kname.readme.txt
                echo "j = $j" >> $kname.readme.txt
                echo "image_name = ${image_names[j]}" >> $kname.readme.txt
                echo "source_name = ${source_names[j]}" >> $kname.readme.txt
                echo "freq_support = ${freq_supports[j]}" >> $kname.readme.txt
                echo "" >> $kname.readme.txt
                echo "datacube = $kdc" >> $kname.readme.txt
                echo "k = $k" >> $kname.readme.txt
                echo "k1 = $k1" >> $kname.readme.txt
                echo "k2 = $k2" >> $kname.readme.txt
                #echo "matched_freq_support = ${t_freq_support[k1]} ${t_freq_support[k2]}" >> $kname.readme.txt
                echo "uvt_name_pattern = $uvt_name_pattern" >> $kname.readme.txt
                echo "matched_data_file = $matched_data_file" >> $kname.readme.txt
                echo "" >> $kname.readme.txt
                # 
                echo "Written to \"$(pwd)/$kname.readme.txt\""
                #cat $kname.readme.txt | grep -v '^$' #<TODO><DEBUG>#
                # 
            done # end the loop of datacubes per dataset
            # 
        fi
        # 
        # 
        # load matched_data_files
        IFS=$'\n' matched_data_files=($(cat "dataset_${kds}_datacube_list.txt" | sed -e 's/^ *//g' | tr -s ' ' | cut -d ' ' -f 1))
        # 
        # 
        # loop each uvt file and run uvfit
        echo "--------"
        echo "Looping ${#matched_data_files[@]} uvt file(s) for uv fitting"
        echo "--------"
        for (( k = 0; k < ${#matched_data_files[@]}; k++ )); do
            # 
            matched_data_file=${matched_data_files[k]}
            # 
            kdc=$((k+1))
            # 
            kname="dataset_${kds}_datacube_${kdc}"
            #
            # run uvfit
            #echo "Reading uvt header"
            #echo "header $kname.uvt" | mapping -nw -nl
            if [[ ! -f "${kname}_go_uvfit.result.obj_1.txt" ]] || [[ $overwrite -ge 2 ]]; then
                # check channel width
                echo "Reading channel width from the header info of the input $kname.uvt"
                IFS=' ' chan_width=($(echo "header $kname.uvt" | mapping -nw -nl | grep '^Resolution in Velocity' | perl -p -e 's/^Resolution in Velocity *([^ ]+?) *in Frequency *([^ ]+?) *$/\1 \2/g'))
                if [[ ${#chan_width[@]} -eq 2 ]]; then
                    # compress the uvt data by velocity
                    #channel_velocity_width=$(echo ${chan_width[0]} | sed -e 's/^-//g') # make it absolute value
                    #compressd_velocity_width=10.0  # compress to velocity resolution 10.0 km/s
                    #compress_factor=$(awk "BEGIN {print int(($compressd_velocity_width)/($channel_velocity_width)/2)*2;}") # int(.../2)*2 makes the compressing factor always an even number. 
                    channel_freq_width=$(echo ${chan_width[1]} | sed -e 's/^-//g') # make it absolute value
                    compressd_freq_width=8.0  # compress to frequency resolution 8 MHz
                    compress_factor=$(awk "BEGIN {print int(($compressd_freq_width)/($channel_freq_width)/2)*2;}") # int(.../2)*2 makes the compressing factor always an even number. 
                    if [[ $(awk "BEGIN {if($compress_factor>1) print 1; else print 0;}") -eq 1 ]]; then
                        echo "Running pdbi-uvt-go-compress -name $kname.uvt -out ${kname}_compressed_by_x${compress_factor}.uvt -width ${compress_factor}"
                        pdbi-uvt-go-compress -name $kname.uvt -out ${kname}_compressed_by_x${compress_factor}.uvt -width ${compress_factor}
                        if [[ -f ${kname}_compressed_by_x${compress_factor}.uvt ]]; then
                            ln -fsT ${kname}_compressed_by_x${compress_factor}.uvt $kname.uvt
                        else
                            echo "Error! Failed to run pdbi-uvt-go-compress -name $kname.uvt -out ${kname}_compressed_by_x${compress_factor}.uvt -width ${compress_factor}!"
                            exit 255
                        fi
                    fi
                else
                    echo "Error! Failed to read channel width from the header info of the input $kname.uvt!"
                    exit 255
                fi
                # run uvfit
                echo "Running pdbi-uvt-go-uvfit"
                echo "Running pdbi-uvt-go-uvfit -name $kname -radec $candidate_RA $candidate_Dec -fixedpos > \"${kname}_go_uvfit.stdout.txt\""
                pdbi-uvt-go-uvfit -name $kname -radec $candidate_RA $candidate_Dec -fixedpos > "${kname}_go_uvfit.stdout.txt"
                rm data*~ data*.backup data*.beam data*.lmv data*.noi 2>/dev/null
                rm "${kname}_go_uvfit.result.obj_1.spectrum.pdf" 2>/dev/null
            else
                echo "Found previous uvfit result table \"${kname}_go_uvfit.result.obj_1.txt\"! Will not overwrite it unless overwrite level >= 2!"
            fi
            # 
            # plot spectrum
            if [[ ! -f "${kname}_go_uvfit.result.obj_1.spectrum.pdf" ]] || [[ $overwrite -ge 1 ]]; then
                echo "Prepare plotting script"
                echo "#!/bin/bash"                                                                                                                                                       >  ./plot_spectrum_for_dataset_${kds}_datacube_${kdc}.sh
                echo "if [[ \$(type pdbi-uvt-go-plot-uvfit-result-spectrum-with-python 2>/dev/null | wc -l) -eq 0 ]]; then source \$HOME/Cloud/Github/Crab.Toolkit.PdBI/SETUP.bash; fi " >> ./plot_spectrum_for_dataset_${kds}_datacube_${kdc}.sh
                echo "cd \$(dirname \${BASH_SOURCE[0]}); echo \"pwd = \$(pwd)\""                                                                                                         >> ./plot_spectrum_for_dataset_${kds}_datacube_${kdc}.sh
                echo "pdbi-uvt-go-plot-uvfit-result-spectrum-with-python \"${kname}_go_uvfit.result.obj_1.txt\" \\"                                                                      >> ./plot_spectrum_for_dataset_${kds}_datacube_${kdc}.sh
                echo "                                           -output \"${kname}_go_uvfit.result.obj_1.spectrum\" \\"                                                                 >> ./plot_spectrum_for_dataset_${kds}_datacube_${kdc}.sh
                echo "                                           -no-errorbar \\"                                                                                                        >> ./plot_spectrum_for_dataset_${kds}_datacube_${kdc}.sh
                echo "                                           -redshift $candidate_z \\"                                                                                              >> ./plot_spectrum_for_dataset_${kds}_datacube_${kdc}.sh
                echo "                                           -linename \"$candidate_line_name\" \\"                                                                                  >> ./plot_spectrum_for_dataset_${kds}_datacube_${kdc}.sh
                echo "                                           -lineFWHM $candidate_line_fwzi \\"                                                                                      >> ./plot_spectrum_for_dataset_${kds}_datacube_${kdc}.sh
                echo "                                           -sigma-clip 6 \\"                                                                                                       >> ./plot_spectrum_for_dataset_${kds}_datacube_${kdc}.sh
                echo "                                           -figsize 15.0 4.0 \\"                                                                                                   >> ./plot_spectrum_for_dataset_${kds}_datacube_${kdc}.sh
                echo "                                           -title \"${obj_name_pattern}_${kname}\" \\"                                                                             >> ./plot_spectrum_for_dataset_${kds}_datacube_${kdc}.sh
                echo "                                           > \"${kname}_go_uvfit.result.obj_1.spectrum.stdout.txt\""                                                               >> ./plot_spectrum_for_dataset_${kds}_datacube_${kdc}.sh
                echo "echo \"Output to \\\"${kname}_go_uvfit.result.obj_1.spectrum.pdf\\\"!\""                                                                                           >> ./plot_spectrum_for_dataset_${kds}_datacube_${kdc}.sh
                echo "Running plotting script for \"${kname}_go_uvfit.result.obj_1.spectrum.pdf\" with linename \"$candidate_line_name\" lineFWHM $candidate_line_fwzi redshift $candidate_z"
                chmod +x ./plot_spectrum_for_dataset_${kds}_datacube_${kdc}.sh
                #cat ./plot_spectrum_for_dataset_${kds}_datacube_${kdc}.sh
                ./plot_spectrum_for_dataset_${kds}_datacube_${kdc}.sh
            else
                echo "Found previous uvfit result spectrum \"${kname}_go_uvfit.result.obj_1.spectrum.pdf\"! Will not overwrite it unless overwrite level >= 1!"
            fi
        done
        # 
        # 
        # if the line name and source redshift is given, 
        # we need to find out which uvt data contain the line, 
        # this can be done by attempts of calling pdbi-uvt-go-average
        # so now we loop each input line name and find uvt files containing the line and extract the line map
        if [[ x"${candidate_line_name}" != x"" ]] && [[ x"${candidate_line_name}" != x"N/A" ]]; then
            # 
            if [[ -f "extracted_line_map_${candidate_line_name}_from_datacube_list.txt" ]] && [[ $overwrite -ge 3 ]]; then
                mv "extracted_line_map_${candidate_line_name}_from_datacube_list.txt" "extracted_line_map_${candidate_line_name}_from_datacube_list.txt.backup"
            fi
            if [[ ! -f "extracted_line_map_${candidate_line_name}_from_datacube_list.txt" ]]; then
                echo "--------"
                echo "Looping ${#matched_data_files[@]} uvt file(s) for extracting the spectral line with line name ${candidate_line_name} at redshift ${candidate_z}"
                echo "--------"
                for (( k = 0; k < ${#matched_data_files[@]}; k++ )); do
                    # 
                    matched_data_file=${matched_data_files[k]}
                    # 
                    kdc=$((k+1))
                    # 
                    kname="dataset_${kds}_datacube_${kdc}"
                    # 
                    extracted_line_map="extracted_line_map_${candidate_line_name}_from_datacube_${kdc}"
                    #
                    # average line channels and make the line map
                    echo "Running pdbi-uvt-go-average -name $kname -out \"${extracted_line_map}.uvt\" -redshift $candidate_z -linename \"$candidate_line_name\" -linewidth $candidate_line_fwzi > \"extracted_line_map_${candidate_line_name}.stdout.txt\""
                    pdbi-uvt-go-average -name $kname -out "${extracted_line_map}.uvt" -redshift $candidate_z -linename "$candidate_line_name" -linewidth $candidate_line_fwzi > "extracted_line_map_${candidate_line_name}.stdout.txt"
                    # check averaged channel range
                    IFS=' ' chan_range=($(cat "extracted_line_map_${candidate_line_name}.stdout.txt" | grep "^Selecting Chan. range" | perl -p -e 's/^Selecting Chan. range: *([^ ]+?) *([^ ]+?) *$/\1 \2/g'))
                    chan_max=$(cat "extracted_line_map_${candidate_line_name}.stdout.txt" | grep '^Chan. Max. *=' | perl -p -e 's/^Chan. Max. *= *([0-9]+) *$/\1/g')
                    if [[ ${#chan_range[@]} -eq 2 ]] && [[ x"${chan_max}" != x"" ]]; then
                        if [[ $(awk "BEGIN {if((${chan_range[0]})<1) print 1; else print 0;}") -eq 1 ]] || [[ $(awk "BEGIN {if((${chan_range[1]})>($chan_max)) print 1; else print 0;}") -eq 1 ]]; then
                            # line out of the valid channel range
                            echo "The input line #candidate_line_name at redshfit $candidate_z is not in the valid range of this uvtable $kname, skip!"
                            rm "${extracted_line_map}.uvt"
                        else
                            echo "The input line #candidate_line_name at redshfit $candidate_z is in the valid range of this uvtable $kname: "
                            grep -A7 '^Selecting Chan. range' "extracted_line_map_${candidate_line_name}.stdout.txt"
                            # store into "extracted_line_map_${candidate_line_name}_from_datacube_list.txt"
                            echo "${extracted_line_map}" >> "extracted_line_map_${candidate_line_name}_from_datacube_list.txt"
                        fi
                    else
                        echo "Error! Failed to run pdbi-uvt-go-average -name $kname -out \"${extracted_line_map}.uvt\" -redshift $candidate_z -linename \"$candidate_line_name\" -linewidth $candidate_line_fwzi and read \"Selecting Chan. range\" and \"Chan. Max. \"!"
                        exit 255
                    fi
                    # 
                    # clear old results
                    if [[ -f "${extracted_line_map}_go_uvfit.result.obj_1.txt" ]]; then
                        mv "${extracted_line_map}_go_uvfit.result.obj_1.txt" "${extracted_line_map}_go_uvfit.result.obj_1.txt.backup"
                    fi
                    if [[ -f "${extracted_line_map}_go_uvfit.result.obj_1.image.pdf" ]]; then
                        mv "${extracted_line_map}_go_uvfit.result.obj_1.image.pdf" "${extracted_line_map}_go_uvfit.result.obj_1.image.pdf.backup"
                    fi
                done
            else
                echo "Found existing \"extracted_line_map_${candidate_line_name}_from_datacube_list.txt\"! Will not overwrite it unless overwrite level >= 3!"
            fi
            # 
            # 
            IFS=$'\n' extracted_line_maps=($(cat "extracted_line_map_${candidate_line_name}_from_datacube_list.txt" | sed -e 's/^ *//g' | tr -s ' ' | cut -d ' ' -f 1))
            # 
            # 
            echo "--------"
            echo "Looping ${#extracted_line_maps[@]} line map(s) to measure the line flux for line name ${candidate_line_name} at redshift ${candidate_z}"
            echo "--------"
            for (( k = 0; k < ${#extracted_line_maps[@]}; k++ )); do
                # 
                extracted_line_map="${extracted_line_maps[k]}"
                # 
                # measure line flux from the line map
                if [[ ! -f "${extracted_line_map}_go_uvfit.result.obj_1.txt" ]] || [[ $overwrite -ge 2 ]]; then
                    echo "Running pdbi-uvt-go-uvfit -name \"${extracted_line_map}.uvt\" -radec $candidate_RA $candidate_Dec -fixedpos > \"${extracted_line_map}_go_uvfit.stdout.txt\""
                    pdbi-uvt-go-uvfit -name "${extracted_line_map}.uvt" -radec $candidate_RA $candidate_Dec -fixedpos > "${extracted_line_map}_go_uvfit.stdout.txt"
                    fit_flux_SNR=$(cat "${extracted_line_map}_go_uvfit.result.obj_1.txt" | head -n 3 | tail -n 1 | sed -e 's/^ *//g' | tr -s ' ' | cut -d ' ' -f 8)
                    if [[ $(awk "BEGIN {if($fit_flux_SNR>4.5) print 1; else print 0;}") -eq 1 ]]; then
                        pdbi-uvt-go-uvfit -name "${extracted_line_map}.uvt" -out "${extracted_line_map}_go_uvfit_2" -radec $candidate_RA $candidate_Dec -variedpos > "${extracted_line_map}_go_uvfit_2.stdout.txt"
                        fit_flux_SNR=$(cat "${extracted_line_map}_go_uvfit_2.result.obj_1.txt" | head -n 3 | tail -n 1 | sed -e 's/^ *//g' | tr -s ' ' | cut -d ' ' -f 8)
                    fi
                    # 
                    # copy to parent folder
                    if [[ -f "${extracted_line_map}_go_uvfit_2.result.obj_1.txt" ]]; then
                        cp "${extracted_line_map}_go_uvfit_2.result.obj_1.txt" ../
                    elif [[ -f "${extracted_line_map}_go_uvfit.result.obj_1.txt" ]]; then
                        cp "${extracted_line_map}_go_uvfit.result.obj_1.txt" ../
                    fi
                    if [[ -f "${extracted_line_map}_go_uvfit_2.result.obj_1.image.pdf" ]]; then
                        cp "${extracted_line_map}_go_uvfit_2.result.obj_1.image.pdf" ../
                    elif [[ -f "${extracted_line_map}_go_uvfit.result.obj_1.image.pdf" ]]; then
                        cp "${extracted_line_map}_go_uvfit.result.obj_1.image.pdf" ../
                    fi
                else
                    echo "Found previous line map uvfit result \"$(pwd)/${extracted_line_map}_go_uvfit.result.obj_1.txt\"! Will not overwrite it unless overwrite level >= 2!"
                fi
                # 
            done
            # 
            # 
        fi # done the loop for data cubes (spws) (freq_supports) of one alma data set (image_names)
        # 
        # plot spectrum for all data cubes (spws) from one data set (alma_image)
        if [[ $kds -gt 0 ]]; then
            echo "Prepare plotting script"
            echo "#!/bin/bash"                                                                                                                                                       >  ../plot_spectrum_for_dataset_${kds}.sh
            echo "if [[ \$(type pdbi-uvt-go-plot-uvfit-result-spectrum-with-python 2>/dev/null | wc -l) -eq 0 ]]; then source \$HOME/Cloud/Github/Crab.Toolkit.PdBI/SETUP.bash; fi " >> ../plot_spectrum_for_dataset_${kds}.sh
            echo "cd \$(dirname \${BASH_SOURCE[0]}); cd \"run_uvfit\"; echo \"pwd = \$(pwd)\""                                                                                       >> ../plot_spectrum_for_dataset_${kds}.sh
            echo "pdbi-uvt-go-plot-uvfit-result-spectrum-with-python \"dataset_${kds}_datacube_\"*\"_go_uvfit.result.obj_1.txt\" \\"                                                 >> ../plot_spectrum_for_dataset_${kds}.sh
            echo "                                           -output \"dataset_${kds}_datacube_all_go_uvfit.result.obj_1.spectrum\" \\"                                              >> ../plot_spectrum_for_dataset_${kds}.sh
            echo "                                           -no-errorbar \\"                                                                                                        >> ../plot_spectrum_for_dataset_${kds}.sh
            echo "                                           -redshift $candidate_z \\"                                                                                              >> ../plot_spectrum_for_dataset_${kds}.sh
            echo "                                           -linename \"$candidate_line_name\" \\"                                                                                  >> ../plot_spectrum_for_dataset_${kds}.sh
            echo "                                           -lineFWHM $candidate_line_fwzi \\"                                                                                      >> ../plot_spectrum_for_dataset_${kds}.sh
            echo "                                           -sigma-clip 6 \\"                                                                                                       >> ../plot_spectrum_for_dataset_${kds}.sh
            echo "                                           -figsize 15.0 4.0 \\"                                                                                                   >> ../plot_spectrum_for_dataset_${kds}.sh
            echo "                                           -title \"ID $candidate_ID RA $candidate_RA Dec $candidate_Dec z $candidate_z dataset ${kds} datacube all\" \\"          >> ../plot_spectrum_for_dataset_${kds}.sh
            echo "                                           > \"dataset_${kds}_datacube_all_go_uvfit.result.obj_1.spectrum.stdout.txt\""                                            >> ../plot_spectrum_for_dataset_${kds}.sh
            echo "echo \"Output to \\\"dataset_${kds}_datacube_all_go_uvfit.result.obj_1.spectrum.pdf\\\"!\""                                                                        >> ../plot_spectrum_for_dataset_${kds}.sh
            echo "cp \"dataset_${kds}_datacube_all_go_uvfit.result.obj_1.spectrum\"* ../"                                                                                            >> ../plot_spectrum_for_dataset_${kds}.sh
            echo "Running plotting script for \"dataset_${kds}_datacube_all_go_uvfit.result.obj_1.spectrum.pdf\" with linename \"$candidate_line_name\" lineFWHM $candidate_line_fwzi redshift $candidate_z"
            chmod +x ../plot_spectrum_for_dataset_${kds}.sh
            #cat ../plot_spectrum_for_dataset_${kds}.sh
            ../plot_spectrum_for_dataset_${kds}.sh
        else
            echo "No data set was found for the input redshift $candidate_z linename \"$candidate_line_name\"?!"
            exit 255
        fi
        echo "--------"
        # 
    done # done the loop for all alma data sets (image_names)
    # 
    # cd back
    cd "../" # out of "run_uvfit"
    # 
    # debug
    #if [[ 1 == 1 ]]; then
    #    exit
    #fi
    # 
    # mark done
    #date "+%Y-%m-%d %H:%M:%S %Z" > "done"
    # 
    # cd back
    cd "../" # out of "candidate_X"
    # 
    # print separator
    echo "--------"
    echo "--------"
    # 
    # debug break
    if [[ $debug_only_one_candidate -gt 0 ]]; then
        break
    fi
done

# 
# cd back
cd "../"




