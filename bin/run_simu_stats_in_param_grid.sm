user_define_param_grid
    # please define params here
    user_define_param_grid_using_galfit_flux_error

user_define_param_grid_using_galfit_flux_error
    # please define params here
    set npar = 2
    set par1 = e_S_out/noise
    set par1_str = 'log e_{S_{out}}/\\sigma_{rms noise}'
    set par1_grid = {0 0.1 1 2 3 5 10 100}
    set par2 = Maj_out
    set par2_str = 'FWHM_{source}'
    set par2_grid = <0 0.1 0.5 $(0.5+0.1) 1.0 2.0 3.0 4.0 5.0 100>
    define outdir sim_diagram_output_using_galfit_flux_error

user_define_param_grid_no_galfit_error
    # please define params here
    set npar = 2
    set par1 = S_peak/noise
    set par1_str = 'S_{peak}/\\sigma_{rms noise}'
    set par1_grid = {0 0.1 1 2 3 5 10 100}
    set par2 = Maj_out
    set par2_str = 'FWHM_{source}/FWHM_{beam}'
    set par2_grid = <0 0.1 0.5 $(0.5+0.1) 1.0 2.0 3.0 4.0 5.0 100>
    define outdir sim_diagram_output_no_galfit_flux_error

user_define_data_file
    # please define params here
    define inputdata "simu_data_input_1000.txt"

read_data_file
    # 
    # User input data file
    user_define_data_file
    # 
    # Read data file
    load rfile.sm
    data $inputdata
    read {id 1 S_in 2 S_out 3 e_S_out 4 S_peak 5 S_res 6 noise 7 Maj_in 8 Min_in 9 Maj_out 10 Min_out 11 Maj_beam 12 Min_beam 13}
    # 
    # check variables 
    define check_columns 1
    foreach var {id Maj_in Min_in S_in S_out e_S_out S_peak S_res noise Maj_out Min_out Maj_beam Min_beam} {
        if(!is_vector($var)) {
            define check_columns 0
            print 'Data column \"$var\" was not found in the input file!\n' {}
        }
    }
    if($check_columns==0) {return}
    # 
    # filter bad sources which have zero S_peak (at the edge of the image)
    set filter = (e_S_out>=0)
    foreach var {id Maj_in Min_in S_in S_out e_S_out S_peak S_res noise Maj_out Min_out Maj_beam Min_beam} {
        set $var = $var if(filter)
    }
    # 
    # print how many sources under analysis
    echo ""
    echo "Analyzing "$(dimen(S_in))" sources"
    echo ""
    # 
    # compute median rms noise
    stats_med noise noise_median noise_kurt
    echo "noise_median = "$noise_median
    echo ""
    # 
    # set S_diff and rel_S_diff
    set S_diff = (S_in - S_out)
    set rel_S_diff = (S_in - S_out)/S_in



run_simu_stats_in_param_grid
    # 
    # Aim:
    #       This program aims at analyzing galaxies' Monte Carlo simulation
    #       and derive correction recipes for fluxes and errors. 
    #       Here we do not use galfit flux errors because their histogram
    #       of ((S_in-S_out)/error_S_out) are far from Gaussian. 
    #       So we should derive flux errors purely based on statistics without prior. 
    # 
    # Usage:
    #       echo "macro read run_simu_stats_in_param_grid.sm run_simu_stats_in_param_grid simu_data_input.txt" | sm
    # 
    #if(!$?1) {
    #    print 'Usage: \n' {} 
    #    print '       macro read run_simu_stats_in_param_grid.sm\n' {}
    #    print '       run_simu_stats_in_param_grid simu_data_input.txt\n' {}
    #    return
    #}
    # 
    # read data file
    read_data_file
    # 
    # define parameters
    user_define_param_grid
    # 
    # define output dir
    if(!$?outdir) {
        define outdir "sim_diagram_output"
    }
    # 
    # mkdir
    !mkdir $outdir 2>/dev/null
    # 
    # 
    # 
    # store uncorr0
    set S_out_uncorr0 = S_out
    set e_S_out_uncorr0 = e_S_out
    # 
    # define param grid statistical measurements
    compute_statistics_in_param_grid_cells



compute_statistics_in_param_grid_cells
    # 
    # Here we determine the grid cells for each param data array
    # 
    if(!is_vector(npar)) {
        print 'Error! npar was not set!\n' {}
        return
    }
    declare cell_id 0.d
    declare cell_median 0.f # (S_in - S_out) median
    declare cell_scatter 0.f # (S_in - S_out) scatter
    declare cell_rel_median 0.f # (S_in - S_out)/S_in median
    declare cell_rel_scatter 0.f # (S_in - S_out)/S_in scatter
    declare cell_rel_scatter_L68 0.f # (S_in - S_out)/S_in scatter
    declare cell_rel_scatter_H68 0.f # (S_in - S_out)/S_in scatter
    declare cell_e_S_out_median 0.f # (e_S_out) median
    do i = 1, npar {
        declare cell_par$i""_median 0.f
        #declare cell_par$i""_mean 0.f
    }
    set cell_minimum_data_points = 5
    set cell_total_number = 1
    # 
    # set bin by which parameters
    do i = 1, npar {
        # check par$i
        if(!is_vector(par$i)) {
            print 'Error! par$i was not set!\n' {}
            return
        }
        # get param min max
        vecminmax par$i tmin tmax
        # get param grid
        if(!is_vector(par$i""_grid)) {
            set par$i""_grid = $tmin,$tmax,$(($tmax-$tmin)/6) # if user has not supplied with a grid, assign a grid of 6 cells per param. 
        }
        # get param str
        if(!is_vector(par$i""_str)) {
            set par$i""_str = 'par$i' # if user has not supplied with a grid, assign a grid of 6 cells per param. 
        }
        # print 
        print 'Bin by param $i: $(par$i""_str), min max: $tmin $tmax' {}
        if($tmin>=$tmax) {
            print '\n' {}
            print 'Error! Could not determine valid min and max for param $i: $(par$i""_str)! Maybe this param contains no valid value?!\n' {}
            exit
        } else {
            print ', param grid:' {}
            do k = 0, dimen(par$i""_grid)-1 {
                print ' $(par$i""_grid[$k])' {}
            }
        }
        print ' (N=$(dimen(par$i""_grid)-1))\n' {}
        set cell_total_number = cell_total_number * $(dimen(par$i""_grid)-1) # note that -1 is because edge list has one more element than cell list. 
    }
    print 'Total grid cells: $(cell_total_number)' {}
    print '\n' {}
    # 
    # print separator
    print '\n--------------------------------------------------------------------------------\n\n' {}
    # 
    # loop each grid cell to compute cell_median, cell_rel_median, etc.
    define icell 1
    do i = 1, npar {
        define i$i 1 # here i$i starts from 1 because our looping array is bin_edges, which has one more element than the bin number. 
    }
    while { $icell <= cell_total_number } {
        # 
        # current cell
        set icell_str = sprintf('%4d',$icell)
        print 'Current cell $(icell_str):' {}
        do i = 1, npar {
            print '\tpars$i ($(par$i""_grid[$i$i-1])-$(par$i""_grid[$i$i]))' {}
        }
        # 
        # select data points in each bin
        set bin_selection = S_in*0+1
        do i = 1, npar {
            # select data points in each bin by excluding lower and upper ranges
            set bin_selection = ( par$i < $(par$i""_grid[$i$i-1]) ) ? 0 : bin_selection
            set bin_selection = ( par$i >= $(par$i""_grid[$i$i]) ) ? 0 : bin_selection
            # consider the last one element
            if($i$i==dimen(par$i""_grid)-1) {
                set bin_selection = ( par$i == $(par$i""_grid[$i$i]) ) ? 1 : bin_selection
            }
        }
        print ', $(sum(bin_selection)) dp' {}
        # 
        # check data points, must have at least some number of data points to compute the statistics
        if(sum(bin_selection)>=cell_minimum_data_points) {
            # 
            # get data arrays in each grid cell bin
            foreach var {S_in S_out e_S_out} {set bin_$var = $var if(bin_selection)}
            do i = 1, npar {set bin_par$i = par$i if(bin_selection)}
            set bin_rel_S_diff = (bin_S_in-bin_S_out)/bin_S_in
            set bin_S_diff = (bin_S_in-bin_S_out)
            # 
            # store param median in each bin
            do i = 1, npar {
                calc_mean_median bin_par$i
                set cell_par$i""_median = cell_par$i""_median concat calc_bin_median
            }
            # 
            # store (S_in-S_out) median -- absolute fbias
            calc_mean_median bin_S_diff
            set cell_median = cell_median concat calc_bin_median
            set cell_scatter = cell_scatter concat calc_bin_sigma
            # 
            # store (S_in-S_out)/S_in median -- relative fbias
            calc_mean_median bin_rel_S_diff 10.0
            set cell_rel_median = cell_rel_median concat calc_bin_median
            # 
            # store (S_in-S_out)/S_in scatter -- relative scatter
            calc_asymmetric_scatters bin_rel_S_diff 10.0
            set cell_rel_scatter_L68 = cell_rel_scatter_L68 concat asym_bin_scatter_L68
            set cell_rel_scatter_H68 = cell_rel_scatter_H68 concat asym_bin_scatter_H68
            set asym_bin_scatter = $asym_bin_array_sigma
            set cell_rel_scatter = cell_rel_scatter concat asym_bin_scatter
            # 
            # store (S_in-S_out)/S_in scatter -- mean galfit flux error
            calc_mean_median bin_e_S_out 10.0
            set cell_e_S_out_median = cell_e_S_out_median concat calc_bin_median
            # 
            # store cell_id
            set cell_id = cell_id concat ($icell)
            # 
            # write cell data
            print $outdir"/datatable_S_diff_cell_id_"$icell".txt" {bin_rel_S_diff bin_par1 bin_par2}
        }
        # 
        print '\n' {}
        # 
        # next cell
        define icell $($icell+1)
        if($icell <= cell_total_number) {
            define i 1
            define i$i $($i$i+1)
            do i = 1, npar {
                if($i$i > (dimen(par$i""_grid)-1)) {
                    #<NOTE># here $i$i > dim is because we use $i$i, which starts from 1, for the bin edge array, which has one more element than the bin array. 
                    define i$i $($i$i-(dimen(par$i""_grid)-1))
                    if($i < npar) {
                        #<NOTE># $i and i$i starts from 1
                        define i$($i+1) $($i$($i+1)+1)
                    }
                }
            }
        }
    }
    # 
    # write 
    load wfile.sm
    set wfile_vectors = {cell_id cell_median cell_scatter cell_rel_median cell_rel_scatter cell_rel_scatter_L68 cell_rel_scatter_H68 cell_e_S_out_median}
    do i = 1, npar { set wfile_vectors = wfile_vectors concat <cell_par$i""_median> }
    wfile $outdir"/datatable_correction.txt"
    # 
    # write 
    #set S_diff = S_in - S_out
    #set rel_S_diff = (S_in - S_out)/S_in
    #set wfile_vectors = {id S_diff rel_S_diff}
    #do i = 1, npar { set wfile_vectors = wfile_vectors concat <par$i> }
    #wfile $outdir"/datatable_S_diff_versus_params.txt"
    
    
    
    
others
        # 
        # read cell parameters from "datatable_cell_parameters.txt"
        #do i = 1, npar {
        #    set bin_cell_par_$i = bin_cell_median*0.0
        #}
        #do k = 0, dimen(bin_cell_id)-1 {
        #    verbose 0
        #    data $outdir"/datatable_cell_parameters.txt"
        #    lines $(bin_cell_id[$k]+2) $(bin_cell_id[$k]+2)
        #    # here +2 considers two commented header lines. 
        #    read <bin_cell_id_in 1>
        #    if(bin_cell_id_in!=bin_cell_id[$k]) {
        #        echo "Error! bin_cell_id_in!=bin_cell_id[$k]"
        #        echo "bin_cell_id_in = "$(bin_cell_id_in)
        #        echo "bin_cell_id[$k] = "$(bin_cell_id[$k])
        #        exit
        #    }
        #    do i = 1, npar {
        #        read <bin_cell_par_$i""_lo $(3*$i) bin_cell_par_$i""_hi $(3*$i+1)>
        #        # columns are : cell_id, par_1_str, par_1_lo, par_1_hi, par_2_str, par_2_lo, par_2_hi, .. --- so the column number is 3*$i
        #        set bin_cell_par_$i[$k] = ((bin_cell_par_$i""_lo+bin_cell_par_$i""_hi)/2.0)
        #        # see our fitted function form above
        #    }
        #    verbose 1
        #}
        # 
        # read cell parameters from "datatable_cell_par_"$i"_mean.txt"
        do i = 1, npar {
            data $outdir"/datatable_cell_par_"$i"_mean.txt" read <bin_cell_par_$i 2.S_out>
        }
        # 
        # print 
        print $outdir"/datatable_cell_median_with_par.txt" '%15.0f %25g %25g %25g\n' {bin_cell_id bin_cell_median bin_cell_par_1 bin_cell_par_2}
        # 
        # 
        # 20171119
        # fit (S_in-S_out)/S_in median as a function of par1, par2, ..., parN
        # Y = a0 / par1**a1 / par2**a2 / ...
        declare fit_a0 0.S_out
        set fit_range_a0 = 2.0,-12.0,-0.5 #<TODO># Tune fit range
        set fit_count_numb = dimen(fit_range_a0)
        do i = 1, npar {
            declare fit_a$i 0.S_out
            set fit_range_a$i = -5.0,5.0,0.2 #<TODO># Tune fit range
            set fit_count_numb = fit_count_numb * dimen(fit_range_a$i)
        }
        declare fit_chi2 0.S_out
        # 
        # sample fitting function parameter space
        define icell 0
        define i0 0
        do i = 1, npar {
            define i$i 0 # here we just use i$i starting from 0
        }
        while { $icell <= fit_count_numb } {
            set _fit_a0 = fit_range_a0[$i0]
            do i = 1, npar {
                set _fit_a$i = fit_range_a$i[$i$i]
            }
            set _fit_chi2 = 0.0
            set _fit_y = _fit_a0
            do i = 1, npar {
                set _fit_y = _fit_y / ((bin_cell_par_$i)**_fit_a$i)
            }
            set _fit_chi2 = _fit_chi2 + sum((bin_cell_median-_fit_y)**2) # fitting (A/x**B) equation
            # 
            # store chi2
            set fit_a0 = fit_a0 concat _fit_a0
            set fit_chi2 = fit_chi2 concat _fit_chi2
            do i = 1, npar {
                set fit_a$i = fit_a$i concat _fit_a$i
            }
            # 
            # next fit parameter grid point
            define icell $($icell+1)
            if($icell < fit_count_numb) {
                define i 0 # here we need to loop a0, a1, a2, ..., aNpar
                define i$i $($i$i+1)
                do i = 0, npar {
                    if($i$i >= dimen(fit_range_a$i)) {
                        #<NOTE># here $i$i >= dim is because $i$i starts from 0.
                        define i$i $($i$i-dimen(fit_range_a$i))
                        if($i < npar) {
                            #<NOTE># $i starts from 1, but here $i$i starts from 0. 
                            define i$($i+1) $($i$($i+1)+1)
                        }
                    }
                }
            }
        }
        # 
        # sort chi2 and get best-fit function parameters
        load wfile.sm
        set wfile_vectors = {fit_chi2 fit_a0}
        do i = 1, npar {
            set wfile_vectors = wfile_vectors concat <fit_a$i>
        }
        wfile $outdir"/datatable_cell_median_function_fitting_chi2.txt"
        # 
        set fit_sort = fit_chi2
        sort <fit_sort fit_a0>
        set wfile_vectors = {fit_chi2 fit_a0}
        do i = 1, npar {
            set fit_sort = fit_chi2
            sort <fit_sort fit_a$i>
            set wfile_vectors = wfile_vectors concat <fit_a$i>
        }
        set fit_sort = fit_chi2
        sort <fit_sort fit_chi2>
        wfile $outdir"/datatable_cell_median_function_fitting_chi2_sorted.txt"
        # 
        # write best-fit function parameters
        set fit_chi2 = fit_chi2[0]
        set fit_a0 = fit_a0[0]
        do i = 1, npar {
            set fit_a$i = fit_a$i[0]
        }
        define print_noheader 1
        print  $outdir"/datatable_cell_median_function.txt" 'set fit_a0 = %0.20g\n' <fit_a0>
        print +$outdir"/datatable_cell_median_function.txt" 'set fit_y = fit_a0\n' {}
        do i = 1, npar {
        print +$outdir"/datatable_cell_median_function.txt" '\#set data_x$i = par$i\n' {}
        print +$outdir"/datatable_cell_median_function.txt" 'set fit_a$i = %0.20g\n' <fit_a$i>
        print +$outdir"/datatable_cell_median_function.txt" 'set fit_y = fit_y / (data_x$i**fit_a$i)\n' {}
        }
        define print_noheader 0
        !cat $outdir"/datatable_cell_median_function.txt"
    }
    # 
    # 
    # 
    # 
    # 
    # 
    # print separator
    print '\n--------------------------------------------------------------------------------\n\n' {}
    # 
    # 
    # 
    # 
    # 
    # 
    # loop each bin cell again to compute df_corr
    set do_overwrite_cell_sigma_function = 0
    if(!is_file($outdir"/datatable_cell_sigma_L68_function.txt") || do_overwrite_cell_sigma_function == 1) {
        define icell 0
        do i = 1, npar {
            define i$i 1 # here i$i starts from 1 because our looping array is bin_edges, which has one more element than the bin number. 
        }
        while { $icell <= cell_total_number } {
            # 
            # current cell
            print 'Current cell $($icell+1):' {}
            do i = 1, npar {
                print '\tpar$i $(par$i""_grid[$i$i-1])-$(par$i""_grid[$i$i])' {}
            }
            # 
            # select data points in each bin
            set bin_selection = S_in*0+1
            do i = 1, npar {
                set bin_selection = par$i < $(par$i""_grid[$i$i-1]) ? 0 : bin_selection
                set bin_selection = par$i >= $(par$i""_grid[$i$i]) ? 0 : bin_selection
            }
            print ', $(sum(bin_selection)) dp' {}
            # 
            # check data points
            if(sum(bin_selection)>=3) {
                # 
                # bin (S_in-S_out)/S_in
                set bin_data = (S_in-S_out)/S_in if(bin_selection==1)
                set bin_data_indices = 0,dimen(S_in)-1
                set bin_data_indices = bin_data_indices if(bin_selection==1)
                # 
                # calc (S_in-S_out)/S_in mean and median
                calc_mean_median bin_data 10.0
                print ',\t(S_in-S_out)/S_in mean $(calc_bin_mean) med $(calc_bin_median)' {}
                # 
                # correct (S_in-S_out)/S_in median
                do i = 1, npar {
                    set data_x$i = par$i if(bin_selection==1)
                }
                input $outdir"/datatable_cell_median_function.txt"
                #--> output fit_y
                # 
                # derive flux density bias
                #     (S_in-S_out)/S_in = calc_bin_median
                # =>  S_in = S_out/(1-calc_bin_median)
                # =>  fbias = (S_in-S_out) = S_out*(1/(1-calc_bin_median)-1) = S_out * (calc_bin_median/(1-calc_bin_median))
                set bin_cell_median = fit_y
                set fbias[bin_data_indices] = S_out[bin_data_indices] * (bin_cell_median/(1-bin_cell_median))
                set S_out[bin_data_indices] = S_out[bin_data_indices] + fbias[bin_data_indices]
                # 
                # 
                # 
                # calc (S_in-S_out)/df sigma after applying fbias correction
                set bin_data = (S_in[bin_data_indices]-S_out[bin_data_indices])/S_in[bin_data_indices]
                calc_asymmetric_scatters bin_data 3.0
                print ',\t(S_in-S_out)/df sig $(asym_bin_scatter_L68) $(asym_bin_scatter_H68)' {}
                # 
                # derive flux density error
                #     (S_in - S_out) / S_in = sig
                # ..  (S_in - S_out) / err = 1.0
                # =>  err = S_in * sig
                # ..  S_out = S_in
                # =>  err = S_out * sig
                set bin_cell_sigma_L68 = asym_bin_scatter_L68
                set bin_cell_sigma_H68 = asym_bin_scatter_H68
                set ferr_L68[bin_data_indices] = S_out[bin_data_indices] * (asym_bin_scatter_L68)
                set ferr_H68[bin_data_indices] = S_out[bin_data_indices] * (asym_bin_scatter_H68)
                # 
                # store bin_cell_id and cell_id
                set bin_cell_id = float($icell+1) # the cell_id starts from 1, so here +1. 
                set cell_id[bin_data_indices] = ($icell+1) # the cell_id starts from 1, so here +1. 
                # 
                # print to "datatable_cell_sigma.txt"
                if(bin_cell_id==1) {
                    define print_noheader 0
                    print $outdir"/datatable_cell_sigma_L68.txt" '%15.0f %25g\n' {bin_cell_id bin_cell_sigma_L68}
                } else {
                    define print_noheader 1
                    print +$outdir"/datatable_cell_sigma_L68.txt" '%15.0f %25g\n' {bin_cell_id bin_cell_sigma_L68}
                    define print_noheader 0
                }
                # 
                # print to "datatable_cell_sigma.txt"
                if(bin_cell_id==1) {
                    define print_noheader 0
                    print $outdir"/datatable_cell_sigma_H68.txt" '%15.0f %25g\n' {bin_cell_id bin_cell_sigma_H68}
                } else {
                    define print_noheader 1
                    print +$outdir"/datatable_cell_sigma_H68.txt" '%15.0f %25g\n' {bin_cell_id bin_cell_sigma_H68}
                    define print_noheader 0
                }
                # 
                # debug bin_data
                print $outdir"/debug_data_fbias_corrected_cell_id_"$(bin_cell_id)".txt" {bin_data}
            }
            # 
            # 
            print '\n' {}
            # 
            # next cell
            define icell $($icell+1)
            if($icell < cell_total_number) {
                define i 1
                define i$i $($i$i+1)
                do i = 1, npar {
                    if($i$i > cell_size[$i-1]) {
                        #<NOTE># here $i$i > dim is because we use $i$i, which starts from 1, for the bin edge array, which has one more element than the bin array. 
                        define i$i $($i$i-cell_size[$i-1])
                        if($i < npar) {
                            #<NOTE># $i and i$i starts from 1
                            define i$($i+1) $($i$($i+1)+1)
                        }
                    }
                }
            }
        }
        # 
        # read cell median from "datatable_cell_sigma_L68.txt"
        data $outdir"/datatable_cell_sigma_L68.txt"
        read {bin_cell_id 1 bin_cell_sigma_L68 2}
        # read cell parameters from "datatable_cell_par_"$i"_mean.txt"
        do i = 1, npar {
            data $outdir"/datatable_cell_par_"$i"_mean.txt" read <bin_cell_par_$i 2.S_out>
        }
        print $outdir"/datatable_cell_sigma_L68_with_par.txt" '%15.0f %25g %25g %25g\n' {bin_cell_id bin_cell_sigma_L68 bin_cell_par_1 bin_cell_par_2}
        # 
        # filter invalid (zero) data points
        set coo = (bin_cell_sigma_L68>0)
        foreach var {bin_cell_id bin_cell_sigma_L68 bin_cell_par_1 bin_cell_par_2} {
            set $var = $var if(coo)
        }
        # 
        # 
        # 20171119
        # fit (S_in-S_out)/S_in sigma_L68 as a function of par1, par2, ..., parN
        # Y = a0 / par1**a1 / par2**a2 / ...
        declare fit_a0 0.S_out
        set fit_range_a0 = 2.0,-10.0,-0.5 #<TODO># Tune fit range
        set fit_count_numb = dimen(fit_range_a0)
        do i = 1, npar {
            declare fit_a$i 0.S_out
            set fit_range_a$i = -5.0,5.0,0.2 #<TODO># Tune fit range
            set fit_count_numb = fit_count_numb * dimen(fit_range_a$i)
        }
        declare fit_chi2 0.S_out
        # 
        # sample fitting function parameter space
        define icell 0
        define i0 0
        do i = 1, npar {
            define i$i 0 # here we just use i$i starting from 0
        }
        while { $icell <= fit_count_numb } {
            set _fit_a0 = fit_range_a0[$i0]
            do i = 1, npar {
                set _fit_a$i = fit_range_a$i[$i$i]
            }
            set _fit_chi2 = 0.0
            set _fit_y = _fit_a0
            do i = 1, npar {
                set _fit_y = _fit_y / ((bin_cell_par_$i)**_fit_a$i)
            }
            set _fit_chi2 = _fit_chi2 + sum((bin_cell_sigma_L68-_fit_y)**2) # fitting (A/x**B) equation
            # 
            # store chi2
            set fit_a0 = fit_a0 concat _fit_a0
            set fit_chi2 = fit_chi2 concat _fit_chi2
            do i = 1, npar {
                set fit_a$i = fit_a$i concat _fit_a$i
            }
            # 
            # next fit parameter grid point
            define icell $($icell+1)
            if($icell < fit_count_numb) {
                define i 0 # here we need to loop a0, a1, a2, ..., aNpar
                define i$i $($i$i+1)
                do i = 0, npar {
                    if($i$i >= dimen(fit_range_a$i)) {
                        #<NOTE># here $i$i >= dim is because $i$i starts from 0.
                        define i$i $($i$i-dimen(fit_range_a$i))
                        if($i < npar) {
                            #<NOTE># $i starts from 1, but here $i$i starts from 0. 
                            define i$($i+1) $($i$($i+1)+1)
                        }
                    }
                }
            }
        }
        # 
        # sort chi2 and get best-fit function parameters
        load wfile.sm
        set wfile_vectors = {fit_chi2 fit_a0}
        do i = 1, npar {
            set wfile_vectors = wfile_vectors concat <fit_a$i>
        }
        wfile $outdir"/datatable_cell_sigma_L68_function_fitting_chi2.txt"
        # 
        set fit_sort = fit_chi2
        sort <fit_sort fit_a0>
        set wfile_vectors = {fit_chi2 fit_a0}
        do i = 1, npar {
            set fit_sort = fit_chi2
            sort <fit_sort fit_a$i>
            set wfile_vectors = wfile_vectors concat <fit_a$i>
        }
        set fit_sort = fit_chi2
        sort <fit_sort fit_chi2>
        wfile $outdir"/datatable_cell_sigma_L68_function_fitting_chi2_sorted.txt"
        # 
        # write best-fit function parameters
        set fit_chi2 = fit_chi2[0]
        set fit_a0 = fit_a0[0]
        do i = 1, npar {
            set fit_a$i = fit_a$i[0]
        }
        define print_noheader 1
        print  $outdir"/datatable_cell_sigma_L68_function.txt" 'set fit_a0 = %0.20g\n' <fit_a0>
        print +$outdir"/datatable_cell_sigma_L68_function.txt" 'set fit_y = fit_a0\n' {}
        do i = 1, npar {
        print +$outdir"/datatable_cell_sigma_L68_function.txt" '\#set data_x$i = par$i\n' {}
        print +$outdir"/datatable_cell_sigma_L68_function.txt" 'set fit_a$i = %0.20g\n' <fit_a$i>
        print +$outdir"/datatable_cell_sigma_L68_function.txt" 'set fit_y = fit_y / (data_x$i**fit_a$i)\n' {}
        }
        define print_noheader 0
        !cat $outdir"/datatable_cell_sigma_L68_function.txt"
        # 
        # 
        # 
        # 
        # 
        # 
        # fit bin_cell_sigma_H68
        declare fit_a0 0.S_out
        set fit_range_a0 = 2.0,-10.0,-0.5 #<TODO># Tune fit range
        set fit_count_numb = dimen(fit_range_a0)
        do i = 1, npar {
            declare fit_a$i 0.S_out
            set fit_range_a$i = -5.0,5.0,0.2 #<TODO># Tune fit range
            set fit_count_numb = fit_count_numb * dimen(fit_range_a$i)
        }
        declare fit_chi2 0.S_out
        # read cell median from "datatable_cell_sigma_H68.txt"
        data $outdir"/datatable_cell_sigma_H68.txt"
        read {bin_cell_id 1 bin_cell_sigma_H68 2}
        # read cell parameters from "datatable_cell_par_"$i"_mean.txt"
        do i = 1, npar {
            data $outdir"/datatable_cell_par_"$i"_mean.txt" read <bin_cell_par_$i 2.S_out>
        }
        print $outdir"/datatable_cell_sigma_H68_with_par.txt" '%15.0f %25g %25g %25g\n' {bin_cell_id bin_cell_sigma_H68 bin_cell_par_1 bin_cell_par_2}
        # 
        # filter invalid (zero) data points
        set coo = (bin_cell_sigma_H68>0)
        foreach var {bin_cell_id bin_cell_sigma_H68 bin_cell_par_1 bin_cell_par_2} {
            set $var = $var if(coo)
        }
        # 
        # 
        # 20171119
        # fit (S_in-S_out)/S_in sigma_H68 as a function of par1, par2, ..., parN
        # Y = a0 / par1**a1 / par2**a2 / ...
        declare fit_a0 0.S_out
        set fit_range_a0 = 2.0,-10.0,-0.5 #<TODO># Tune fit range
        set fit_count_numb = dimen(fit_range_a0)
        do i = 1, npar {
            declare fit_a$i 0.S_out
            set fit_range_a$i = -5.0,5.0,0.2 #<TODO># Tune fit range
            set fit_count_numb = fit_count_numb * dimen(fit_range_a$i)
        }
        declare fit_chi2 0.S_out
        # 
        # sample fitting function parameter space
        define icell 0
        define i0 0
        do i = 1, npar {
            define i$i 0 # here we just use i$i starting from 0
        }
        while { $icell <= fit_count_numb } {
            set _fit_a0 = fit_range_a0[$i0]
            do i = 1, npar {
                set _fit_a$i = fit_range_a$i[$i$i]
            }
            set _fit_chi2 = 0.0
            set _fit_y = _fit_a0
            do i = 1, npar {
                set _fit_y = _fit_y / ((bin_cell_par_$i)**_fit_a$i)
            }
            set _fit_chi2 = _fit_chi2 + sum((bin_cell_sigma_H68-_fit_y)**2) # fitting (A/x**B) equation
            # 
            # store chi2
            set fit_a0 = fit_a0 concat _fit_a0
            set fit_chi2 = fit_chi2 concat _fit_chi2
            do i = 1, npar {
                set fit_a$i = fit_a$i concat _fit_a$i
            }
            # 
            # next fit parameter grid point
            define icell $($icell+1)
            if($icell < fit_count_numb) {
                define i 0 # here we need to loop a0, a1, a2, ..., aNpar
                define i$i $($i$i+1)
                do i = 0, npar {
                    if($i$i >= dimen(fit_range_a$i)) {
                        #<NOTE># here $i$i >= dim is because $i$i starts from 0.
                        define i$i $($i$i-dimen(fit_range_a$i))
                        if($i < npar) {
                            #<NOTE># $i starts from 1, but here $i$i starts from 0. 
                            define i$($i+1) $($i$($i+1)+1)
                        }
                    }
                }
            }
        }
        # 
        # sort chi2 and get best-fit function parameters
        load wfile.sm
        set wfile_vectors = {fit_chi2 fit_a0}
        do i = 1, npar {
            set wfile_vectors = wfile_vectors concat <fit_a$i>
        }
        wfile $outdir"/datatable_cell_sigma_H68_function_fitting_chi2.txt"
        # 
        set fit_sort = fit_chi2
        sort <fit_sort fit_a0>
        set wfile_vectors = {fit_chi2 fit_a0}
        do i = 1, npar {
            set fit_sort = fit_chi2
            sort <fit_sort fit_a$i>
            set wfile_vectors = wfile_vectors concat <fit_a$i>
        }
        set fit_sort = fit_chi2
        sort <fit_sort fit_chi2>
        wfile $outdir"/datatable_cell_sigma_H68_function_fitting_chi2_sorted.txt"
        # 
        # write best-fit function parameters
        set fit_chi2 = fit_chi2[0]
        set fit_a0 = fit_a0[0]
        do i = 1, npar {
            set fit_a$i = fit_a$i[0]
        }
        define print_noheader 1
        print  $outdir"/datatable_cell_sigma_H68_function.txt" 'set fit_a0 = %0.20g\n' <fit_a0>
        print +$outdir"/datatable_cell_sigma_H68_function.txt" 'set fit_y = fit_a0\n' {}
        do i = 1, npar {
        print +$outdir"/datatable_cell_sigma_H68_function.txt" '\#set data_x$i = par$i\n' {}
        print +$outdir"/datatable_cell_sigma_H68_function.txt" 'set fit_a$i = %0.20g\n' <fit_a$i>
        print +$outdir"/datatable_cell_sigma_H68_function.txt" 'set fit_y = fit_y / (data_x$i**fit_a$i)\n' {}
        }
        define print_noheader 0
        !cat $outdir"/datatable_cell_sigma_H68_function.txt"
    }
    # 
    # 
    # 
    # 
    # 
    # 
    # apply corrections
    if(1) {
        set MajBeam_uncorr0 = MajBeam
        set MajBeam = (MajBeam<0.25) ? 0.25 : MajBeam
        # 
        # 
        # 
        # correct (S_in-S_out)/S_in median
        do i = 1, npar {
            set data_x$i = par$i
        }
        input $outdir"/datatable_cell_median_function.txt"
        #--> output fit_y
        # 
        # 
        # 
        # derive flux density bias
        #     (S_in-S_out)/S_in = calc_bin_median
        # =>  S_in = S_out/(1-calc_bin_median)
        # =>  fbias = (S_in-S_out) = S_out*(1/(1-calc_bin_median)-1) = S_out * (calc_bin_median/(1-calc_bin_median))
        set fit_median = fit_y
        set fbias = S_out * (fit_y/(1-fit_y))
        set S_out = S_out + fbias
        # 
        # 
        # 
        # correct (S_in-S_out)/S_in sigma
        do i = 1, npar {
            set data_x$i = par$i
        }
        input $outdir"/datatable_cell_sigma_L68_function.txt"
        #--> output fit_y
        # 
        # derive flux density error
        #     (S_in - S_out) / S_in = sig
        # ..  (S_in - S_out) / err = 1.0
        # =>  err = S_in * sig
        # ..  S_out = S_in
        # =>  err = S_out * sig
        set fit_sigma_L68 = fit_y
        set ferr_L68 = S_out * (fit_y)
        # 
        # 
        # 
        # correct (S_in-S_out)/S_in sigma
        do i = 1, npar {
            set data_x$i = par$i
        }
        input $outdir"/datatable_cell_sigma_H68_function.txt"
        #--> output fit_y
        # 
        # derive flux density error
        #     (S_in - S_out) / S_in = sig
        # ..  (S_in - S_out) / err = 1.0
        # =>  err = S_in * sig
        # ..  S_out = S_in
        # =>  err = S_out * sig
        set fit_sigma_H68 = fit_y
        set ferr_H68 = S_out * (fit_y)
        # 
        # 
        # 
        # debug
        print $outdir"/debug_correction_function_fit_y.txt" '%15.0f %15g %15g %15g %15g %15g %15g\n' {id MajBeam fpeakSNR fit_median fit_sigma_L68 fit_sigma_H68}
        # 
        # 
        # 
        # set MajBeam back without lower limit of 0.25
        set MajBeam = MajBeam_uncorr0
        # 
        # 
        # 
        # print corrected S_out df
        set wfile_vectors = {id S_in f_uncorr0 S_out fbias ferr_L68 ferr_H68 cell_id snr_total S_peak noise S_res Maj Min beam_maj beam_min sim_alma_image_STR sim_repetition_STR}
        load wfile.sm
        wfile $outdir"/datatable_corrected.txt"
    }
    
    
    
    
    exit
    # 
    # 
    # 
    # bin by Maj
    set MajBeam_BinEdges = {0.0 0.25 0.50 0.75 1.00 1.25 1.50 1.75 2.00 2.50 3.00 3.50 5.00}
    # 
    go_calc_bin_scatter ((MajBeam)) ((S_in-S_out)/S_in) ((MajBeam_BinEdges))
    go_plot_bin_scatter "MajBeam" "(S_{in}-S_{out})/S_{in}"
    go_save_bin_scatter "MajBeam" "(S_{in}-S_{out})/S_{in}"
    # 
    go_calc_bin_scatter ((MajBeam)) ((S_in-S_out)/S_out) ((MajBeam_BinEdges))
    go_plot_bin_scatter "MajBeam" "(S_{in}-S_{out})/S_{out}"
    go_save_bin_scatter "MajBeam" "(S_{in}-S_{out})/S_{out}"
    # 
    go_calc_bin_scatter ((MajBeam)) ((S_in-S_out)) ((MajBeam_BinEdges))
    go_plot_bin_scatter "MajBeam" "(S_{in}-S_{out})"
    go_save_bin_scatter "MajBeam" "(S_{in}-S_{out})"
    # 
    go_corr_by_param MajBeam
    # 
    # 
    # 
    # bin by fpeakSNR
    set fpeakSNR = S_peak/noise
    #set fpeakSNR_BinEdges = {2.0 2.5 3.0 3.5 4.0 4.5 5 6 7 8 9 10 20 100}
    set fpeakSNR_BinEdges = {2.0 2.5 3.0 3.5 4 5 7 10 20 100}
    # 
    go_calc_bin_scatter ((fpeakSNR)) ((S_in-S_out)/S_in) ((fpeakSNR_BinEdges))
    go_plot_bin_scatter "log peak SNR" "(S_{in}-S_{out})/S_{in}"
    go_save_bin_scatter "peak_SNR" "(S_{in}-S_{out})/S_{in}"
    # 
    go_calc_bin_scatter ((fpeakSNR)) ((S_in-S_out)/S_out) ((fpeakSNR_BinEdges))
    go_plot_bin_scatter "log peak SNR" "(S_{in}-S_{out})/S_{out}"
    go_save_bin_scatter "peak_SNR" "(S_{in}-S_{out})/S_{out}"
    # 
    go_calc_bin_scatter ((fpeakSNR)) ((S_in-S_out)) ((fpeakSNR_BinEdges))
    go_plot_bin_scatter "log peak SNR" "(S_{in}-S_{out})"
    go_save_bin_scatter "peak_SNR" "(S_{in}-S_{out})"
    # 
    # correct by fpeakSNR
    go_corr_by_param fpeakSNR
    # 
    # 
    # 
    # bin by fpeakSNR and plot (S_{in}-S_{out,uncorr})/\sigma
    go_calc_bin_scatter ((fpeakSNR_uncorr0)) ((S_in-f_uncorr0)/df_uncorr0) ((fpeakSNR_BinEdges))
    go_plot_bin_scatter "log peak SNR (uncorr)" "(S_{in}-S_{out,uncorr})/\sigma_{uncorr}"
    go_save_bin_scatter "peak_SNR_uncorr" "(S_{in}-S_{out,uncorr})/\sigma_{uncorr}"
    # 
    go_calc_bin_scatter ((fpeakSNR)) ((S_in-S_out)/df) ((fpeakSNR_BinEdges))
    go_plot_bin_scatter "log peak SNR (corr)" "(S_{in}-S_{out,corr})/\sigma_{corr}"
    go_save_bin_scatter "peak_SNR_corr" "(S_{in}-S_{out,corr})/\sigma_{corr}"
    # 
    # 
    # 
    # bin by ftotalSNR
    set ftotalSNR = S_out/df
    #set ftotalSNR_BinEdges = {2.0 2.5 3.0 3.5 4.0 4.5 5 6 7 8 9 10 20 100}
    set ftotalSNR_BinEdges = {2.0 2.5 3.0 3.5 4 5 7 10 20 100}
    # 
    go_calc_bin_scatter ((ftotalSNR_uncorr0)) ((S_in-f_uncorr0)/S_in) ((ftotalSNR_BinEdges))
    go_plot_bin_scatter "log total SNR (uncorr)" "(S_{in}-S_{out,uncorr})/S_{in}"
    go_save_bin_scatter "total_SNR (uncorr)" "(S_{in}-S_{out,uncorr})/S_{in}"
    # 
    go_calc_bin_scatter ((ftotalSNR)) ((S_in-S_out)/S_in) ((ftotalSNR_BinEdges))
    go_plot_bin_scatter "log total SNR (corr)" "(S_{in}-S_{out,corr})/S_{in}"
    go_save_bin_scatter "total_SNR (corr)" "(S_{in}-S_{out,corr})/S_{in}"
    # 
    go_calc_bin_scatter ((ftotalSNR_uncorr0)) ((S_in-f_uncorr0)/f_uncorr0) ((ftotalSNR_BinEdges))
    go_plot_bin_scatter "log total SNR (uncorr)" "(S_{in}-S_{out,uncorr})/S_{out,uncorr}"
    go_save_bin_scatter "total_SNR (uncorr)" "(S_{in}-S_{out,uncorr})/S_{out,uncorr}"
    # 
    go_calc_bin_scatter ((ftotalSNR)) ((S_in-S_out)/S_out) ((ftotalSNR_BinEdges))
    go_plot_bin_scatter "log total SNR (corr)" "(S_{in}-S_{out,corr})/S_{out,corr}"
    go_save_bin_scatter "total_SNR (corr)" "(S_{in}-S_{out,corr})/S_{out,corr}"
    # 
    go_calc_bin_scatter ((ftotalSNR_uncorr0)) ((S_in-f_uncorr0)) ((ftotalSNR_BinEdges))
    go_plot_bin_scatter "log total SNR (uncorr)" "(S_{in}-S_{out,uncorr})"
    go_save_bin_scatter "total_SNR (uncorr)" "(S_{in}-S_{out,uncorr})"
    # 
    go_calc_bin_scatter ((ftotalSNR)) ((S_in-S_out)) ((ftotalSNR_BinEdges))
    go_plot_bin_scatter "log total SNR (corr)" "(S_{in}-S_{out,corr})"
    go_save_bin_scatter "total_SNR (corr)" "(S_{in}-S_{out,corr})"
    # 
    # 
    # 
    # bin by S_{in} and other parameters
    go_calc_bin_scatter (lg(S_in)) ((S_in-S_out))
    go_plot_bin_scatter "pow S_{in}" "(S_{in}-S_{out,corr})"
    go_save_bin_scatter "pow S_{in}" "(S_{in}-S_{out,corr})"
    # 
    go_calc_bin_scatter (lg(S_in)) ((S_in-f_uncorr0))
    go_plot_bin_scatter "pow S_{in}" "(S_{in}-S_{out,uncorr})"
    go_save_bin_scatter "pow S_{in}" "(S_{in}-S_{out,uncorr})"
    # 
    go_calc_bin_scatter (lg(S_out)) ((S_in-S_out))
    go_plot_bin_scatter "pow S_{out,corr}" "(S_{in}-S_{out,corr})"
    go_save_bin_scatter "pow S_{out,corr}" "(S_{in}-S_{out,corr})"
    # 
    go_calc_bin_scatter (lg(f_uncorr0)) ((S_in-f_uncorr0))
    go_plot_bin_scatter "pow S_{out,uncorr}" "(S_{in}-S_{out,uncorr})"
    go_save_bin_scatter "pow S_{out,uncorr}" "(S_{in}-S_{out,uncorr})"
    #
    go_calc_bin_scatter (lg(S_in)) ((S_in-S_out)/S_in)
    go_plot_bin_scatter "pow S_{in}" "(S_{in}-S_{out,corr})/S_{in}"
    go_save_bin_scatter "pow S_{in}" "(S_{in}-S_{out,corr})/S_{in}"
    #
    go_calc_bin_scatter (lg(S_in)) ((S_in-f_uncorr0)/S_in)
    go_plot_bin_scatter "pow S_{in}" "(S_{in}-S_{out,uncorr})/S_{out,uncorr}"
    go_save_bin_scatter "pow S_{in}" "(S_{in}-S_{out,uncorr})/S_{out,uncorr}"
    #
    go_calc_bin_scatter (lg(S_out)) ((S_in-S_out)/S_in)
    go_plot_bin_scatter "pow S_{out,corr}" "(S_{in}-S_{out,corr})/S_{in}"
    go_save_bin_scatter "pow S_{out,corr}" "(S_{in}-S_{out,corr})/S_{in}"
    #
    go_calc_bin_scatter (lg(f_uncorr0)) ((S_in-f_uncorr0)/S_in)
    go_plot_bin_scatter "pow S_{out,uncorr}" "(S_{in}-S_{out,uncorr})/S_{out,uncorr}"
    go_save_bin_scatter "pow S_{out,uncorr}" "(S_{in}-S_{out,uncorr})/S_{out,uncorr}"
    # 
    # 
    # 
    set SinRMS_BinEdges = {1.0 2.0 3.0 4 6 10 30 100}
    go_calc_bin_scatter ((S_in/noise)) ((S_in-f_uncorr0)/S_in) ((SinRMS_BinEdges))
    go_plot_bin_scatter "log S_{in}/\sigma_{rms}" "(S_{in}-S_{out,uncorr})/S_{in}"
    go_save_bin_scatter "log S_{in}/\sigma_{rms}" "(S_{in}-S_{out,uncorr})/S_{in}"
    # 
    set SinRMS_BinEdges = {1.0 2.0 3.0 4 6 10 30 100}
    go_calc_bin_scatter ((S_in/noise)) ((S_in-S_out)/S_in) ((SinRMS_BinEdges))
    go_plot_bin_scatter "log S_{in}/\sigma_{rms}" "(S_{in}-S_{out,corr})/S_{in}"
    go_save_bin_scatter "log S_{in}/\sigma_{rms}" "(S_{in}-S_{out,corr})/S_{in}"
    # 
    set SoutRMS_BinEdges = {1.0 2.0 3.0 4 6 10 30 100}
    go_calc_bin_scatter ((f_uncorr0/noise)) ((S_in-f_uncorr0)/S_in) ((SoutRMS_BinEdges))
    go_plot_bin_scatter "log S_{out,uncorr}/\sigma_{rms}" "(S_{in}-S_{out,uncorr})/S_{in}"
    go_save_bin_scatter "log S_{out,uncorr}/\sigma_{rms}" "(S_{in}-S_{out,uncorr})/S_{in}"
    # 
    set SoutRMS_BinEdges = {1.0 2.0 3.0 4 6 10 30 100}
    go_calc_bin_scatter ((S_out/noise)) ((S_in-S_out)/S_in) ((SoutRMS_BinEdges))
    go_plot_bin_scatter "log S_{out,corr}/\sigma_{rms}" "(S_{in}-S_{out,corr})/S_{in}"
    go_save_bin_scatter "log S_{out,corr}/\sigma_{rms}" "(S_{in}-S_{out,corr})/S_{in}"
    # 
    # 
    # 
    set SinRMS_BinEdges = {1.0 2.0 3.0 4 6 10 30 100}
    go_calc_bin_scatter ((S_in/noise)) ((S_in-f_uncorr0)) ((SinRMS_BinEdges))
    go_plot_bin_scatter "log S_{in}/\sigma_{rms}" "(S_{in}-S_{out,uncorr})"
    go_save_bin_scatter "log S_{in}/\sigma_{rms}" "(S_{in}-S_{out,uncorr})"
    # 
    set SinRMS_BinEdges = {1.0 2.0 3.0 4 6 10 30 100}
    go_calc_bin_scatter ((S_in/noise)) ((S_in-S_out)) ((SinRMS_BinEdges))
    go_plot_bin_scatter "log S_{in}/\sigma_{rms}" "(S_{in}-S_{out,corr})"
    go_save_bin_scatter "log S_{in}/\sigma_{rms}" "(S_{in}-S_{out,corr})"
    # 
    set SoutRMS_BinEdges = {1.0 2.0 3.0 4 6 10 30 100}
    go_calc_bin_scatter ((f_uncorr0/noise)) ((S_in-f_uncorr0)) ((SoutRMS_BinEdges))
    go_plot_bin_scatter "log S_{out,uncorr}/\sigma_{rms}" "(S_{in}-S_{out,uncorr})"
    go_save_bin_scatter "log S_{out,uncorr}/\sigma_{rms}" "(S_{in}-S_{out,uncorr})"
    # 
    set SoutRMS_BinEdges = {1.0 2.0 3.0 4 6 10 30 100}
    go_calc_bin_scatter ((S_out/noise)) ((S_in-S_out)) ((SoutRMS_BinEdges))
    go_plot_bin_scatter "log S_{out,corr}/\sigma_{rms}" "(S_{in}-S_{out,corr})"
    go_save_bin_scatter "log S_{out,corr}/\sigma_{rms}" "(S_{in}-S_{out,corr})"
    # 
    #go_calc_bin_scatter (lg(S_out)) ((S_in-S_out)/S_out)
    #go_plot_bin_scatter "pow S_{out}" "(S_{in}-S_{out})/S_{out}"
    #go_save_bin_scatter "pow S_{out}" "(S_{in}-S_{out})/S_{out}"
    # 
    # 
    # 
    check_outliers
    # 
    #plot_S_in_S_out
    #plot_S_in_S_out_versus_Param 1
    #plot_S_in_S_out_versus_Param 2
    #plot_S_in_S_out_versus_Param 3
    #plot_S_in_S_out_versus_Param S_in
    #plot_S_in_S_out_versus_Param Tf
    #plot_XfmTfEdf_versus_Param 1
    #plot_XfmTfEdf_versus_Param 2
    #plot_XfmTfEdf_versus_Param 3
    #plot_XfmTfEdf_versus_Param S_in
    #plot_XfmTfEdf_versus_Param Tf


















calc_mean_median 02
    # $1 is data array
    # $2 is sigma clip
    # output:
    #           calc_bin_mean
    #           calc_bin_median
    #           calc_bin_sigma
    if($?1) {
        set calc_bin_array = $1
        stats calc_bin_array calc_bin_array_mean calc_bin_array_sigma calc_bin_array_kurt
        stats_med calc_bin_array calc_bin_array_median calc_bin_array_siqr
        # 
        # apply sigma clip according to $2
        if($?2) {
            set calc_bin_array_clipped = calc_bin_array if(abs(calc_bin_array-$calc_bin_array_mean)<=float($2)*$calc_bin_array_sigma)
            stats calc_bin_array_clipped calc_bin_array_mean calc_bin_array_sigma calc_bin_array_kurt
            stats_med calc_bin_array_clipped calc_bin_array_median calc_bin_array_siqr
        }
        set calc_bin_mean = $calc_bin_array_mean
        set calc_bin_median = $calc_bin_array_median
        set calc_bin_sigma = $calc_bin_array_sigma
    }





calc_asymmetric_scatters 02
    # $1 is data array
    # $2 is sigma clip
    # output: 
    #           asym_bin_scatter_L68
    #           asym_bin_scatter_H68
    if($?1) {
        set asym_bin_array = $1
        stats asym_bin_array asym_bin_array_mean asym_bin_array_sigma asym_bin_array_kurtosis
        #stats_med asym_bin_array asym_bin_array_median asym_bin_array_siqr
        # 
        # apply sigma clip according to $2
        if($?2) {
            set asym_bin_array_clipped = asym_bin_array if(abs(asym_bin_array-$asym_bin_array_mean)<=float($2)*$asym_bin_array_sigma)
            stats asym_bin_array_clipped asym_bin_array_mean asym_bin_array_sigma asym_bin_array_kurtosis
        }
        # 
        # apply mean bias
        set asym_bin_array = asym_bin_array - $asym_bin_array_mean
        vecminmax asym_bin_array asym_bin_array_min asym_bin_array_max
        stats asym_bin_array asym_bin_array_mean asym_bin_array_sigma asym_bin_array_kurtosis
        #stats_med asym_bin_array asym_bin_array_median asym_bin_array_siqr
        # 
        # compute assymetic sigma
        if($asym_bin_array_min < $asym_bin_array_max) {
            set asym_bin_k = 0.0
            set asym_bin_scatter_H68 = 0.0
            set asym_bin_array_scan_leg = abs($asym_bin_array_sigma)/50.0 # determine scan leg
            if(asym_bin_array_scan_leg > abs($asym_bin_array_max)/50.0) {
                set asym_bin_array_scan_leg = abs($asym_bin_array_max)/50.0
            }
            while { asym_bin_k<=$asym_bin_array_max } {
                #set asym_bin_scatter_H68 = asym_bin_k
                if(sum(asym_bin_array>=0 && asym_bin_array<asym_bin_k) > sum(asym_bin_array>=0)*0.682689492137086) {
                    set asym_bin_scatter_H68 = asym_bin_k
                    break
                }
                set asym_bin_k = asym_bin_k + asym_bin_array_scan_leg
            }
            # check
            if(asym_bin_scatter_H68==0) {
                print '\nError! Failed to compute asym_bin_scatter_H68 by step $(asym_bin_array_scan_leg) from 0 to $asym_bin_array_max!\n' {}
                print {asym_bin_array}
            }
            # 
            set asym_bin_k = 0.0
            set asym_bin_scatter_L68 = 0.0
            set asym_bin_array_scan_leg = abs($asym_bin_array_sigma)/50.0 # determine scan leg
            if(asym_bin_array_scan_leg > abs($asym_bin_array_min)/50.0) {
                set asym_bin_array_scan_leg = abs($asym_bin_array_min)/50.0
            }
            while { asym_bin_k>=$asym_bin_array_min } {
                #set asym_bin_scatter_L68 = abs(asym_bin_k)
                if(sum(asym_bin_array<=0 && asym_bin_array>asym_bin_k) > sum(asym_bin_array<=0)*0.682689492137086) {
                    set asym_bin_scatter_L68 = abs(asym_bin_k)
                    break
                }
                set asym_bin_k = asym_bin_k - asym_bin_array_scan_leg
                #<DEBUG># echo asym_bin_k=$(asym_bin_k) sum(asym_bin_array<=0 && asym_bin_array>asym_bin_k)=$(sum(asym_bin_array<=0 && asym_bin_array>asym_bin_k))
            }
            # check
            if(asym_bin_scatter_L68==0) {
                print '\nError! Failed to compute asym_bin_scatter_L68 by step $(asym_bin_array_scan_leg) from $asym_bin_array_min to 0!\n' {}
                print {asym_bin_array}
            }
        }
    }





go_calc_bin_scatter 03
    # 
    # analyze (S_in-S_out)/S_in agains xarray per bin
    set xArray = ($1)
    set yArray = ($2)
    set zArray = (S_in-S_out) # always compute (S_in-S_out) scatter
    vecminmax xArray xMin xMax
    if($?3) {
        set xBinEdges = ($3)
    } else {
        set xBinNumb = 10
        set xBinStep = ($xMax-$xMin)/float(xBinNumb)
        set xBinEdges = $xMin,$xMax+0.5*xBinStep,xBinStep
    }
    # 
    set xBinNumb = dimen(xBinEdges)-1
    # 
    declare xBinLower 0.S_out
    declare xBinUpper 0.S_out
    declare xBinValue 0.S_out
    declare yBinValue 0.S_out
    declare yBinError 0.S_out
    declare yBinErrLo 0.S_out
    declare yBinErrHi 0.S_out
    declare zBinValue 0.S_out
    declare zBinError 0.S_out
    declare zBinErrLo 0.S_out
    declare zBinErrHi 0.S_out
    declare xBinNumber 0.S_out
    do i=1,xBinNumb {
        if($i==xBinNumb) {
            set yBinArray = yArray if(xArray>=xBinEdges[$i-1] && xArray<=xBinEdges[$i])
            set zBinArray = zArray if(xArray>=xBinEdges[$i-1] && xArray<=xBinEdges[$i])
        } else {
            set yBinArray = yArray if(xArray>=xBinEdges[$i-1] && xArray<xBinEdges[$i])
            set zBinArray = zArray if(xArray>=xBinEdges[$i-1] && xArray<xBinEdges[$i])
        }
        if(dimen(yBinArray)>5) {
            #<TODO># make sure there are enough data points in a bin
            stats yBinArray yBinMean yBinSigma yBinKurt
            stats zBinArray zBinMean zBinSigma zBinKurt
            stats_med yBinArray yBinMedian yBinSIQR
            stats_med zBinArray zBinMedian zBinSIQR
            set yBinArray2 = yBinArray - $yBinMedian
            set zBinArray2 = zBinArray - $zBinMedian
            stats yBinArray2 yBinMean2 yBinSigma2 yBinKurt2
            stats zBinArray2 zBinMean2 zBinSigma2 zBinKurt2
            set xBinLower = xBinLower concat ((xBinEdges[$i-1]))
            set xBinUpper = xBinUpper concat ((xBinEdges[$i]))
            set xBinValue = xBinValue concat $((xBinEdges[$i]+xBinEdges[$i-1])/2.0)
            set yBinValue = yBinValue concat $yBinMedian
            set yBinError = yBinError concat $yBinSigma2
            set zBinValue = zBinValue concat $zBinMedian
            set zBinError = zBinError concat $zBinSigma2
            set xBinNumber = xBinNumber concat $(dimen(yBinArray))
            # 
            #vecminmax yBinArray2 yBinArray2Min yBinArray2Max
            #vecminmax zBinArray2 zBinArray2Min zBinArray2Max
            #echo Bin range $(xBinEdges[$i-1]) $(xBinEdges[$i]), yBinArray2 Min $yBinArray2Min Max $yBinArray2Max
            #set yBinArray3 = yBinArray2 if(abs(yBinArray2-$yBinMean2)<20.0*$yBinSigma2) # doClip
            calc_asymmetric_scatters yBinArray2
            set yBinErrHi = yBinErrHi concat asym_bin_scatter_H68
            set yBinErrLo = yBinErrLo concat asym_bin_scatter_L68
            # 
            #set zBinArray3 = zBinArray2 if(abs(zBinArray2-$zBinMean2)<20.0*$zBinSigma2) # doClip
            calc_asymmetric_scatters zBinArray2
            set zBinErrHi = zBinErrHi concat asym_bin_scatter_H68
            set zBinErrLo = zBinErrLo concat asym_bin_scatter_L68
        }
    }
    # 
    # set binVolume = {3 3 3 2 2 2 1 1 1 1}
    # load crabStat.sm
    # crabStat_vecBins (xArray) binVolume binCen binHis (yArray) MeanInBin MedianInBin SigmaInBin RMSInBin
    # set xBinNumb = dimen(binVolume)
    # set xBinEdges = fenBinEdges
    # set xBinValue = binCen
    # set yBinValue = MedianInBin
    # set yBinError = SigmaInBin
    # 


go_plot_bin_scatter 02
    # 
    define check_vectors 1
    foreach var {xBinEdges xBinValue yBinValue yBinError yBinErrLo yBinErrHi xBinNumber xArray yArray} {
        if(!is_vector($var)) {
            print 'Error! Vector $var does not exist!\n' {}
            define check_vectors 0
        }
    }
    if($check_vectors==0) {return}
    # 
    set xPlotStr = <$1> # $1 and $2 must be quoted by double-quotes
    set yPlotStr = <$2> # $1 and $2 must be quoted by double-quotes
    set xPlotArr = xArray # all data points
    set yPlotArr = yArray # all data points
    set xPlotEdg = xBinEdges
    set xPlotVar = xBinValue # bin average
    set yPlotVar = yBinValue # bin average
    set yPlotErr = yBinError # bin scatter
    set yPlotELo = yBinErrLo # bin scatter
    set yPlotEHi = yBinErrHi # bin scatter
    set xPlotLim = xPlotArr
    set yPlotLim = yPlotArr # (yPlotVar*1.5) concat (-yPlotVar*1.5)
    set xPlotTic = {0 0}
    set yPlotTic = {0 0}
    if(index(xPlotStr,'_SNR')>=0 || \
       index(xPlotStr,' SNR')>=0 || \
       index(xPlotStr,'S_{out}/\\sigma')>=0 || \
       index(xPlotStr,'S_{out,uncorr}/\\sigma')>=0 || \
       index(xPlotStr,'S_{out,corr}/\\sigma')>=0 || \
       index(xPlotStr,'S_{in}/\\sigma')>=0 ) { \
                                    set xPlotLim = {0.5 100} }
    if(index(xPlotStr,'log ')==0) { set xPlotArr = lg(xPlotArr)
                                    set xPlotVar = lg(xPlotVar)
                                    set xPlotEdg = lg(xPlotEdg)
                                    set xPlotStr = substr(xPlotStr,4,0)
                                    set xPlotLim = lg(xPlotLim)
                                    set xPlotTic = {-1 5} }
    if(index(yPlotStr,'log ')==0) { set yPlotArr = lg(yPlotArr)
                                    set yPlotErr = yPlotErr/yPlotVar*1.08
                                    set yPlotELo = yPlotELo/yPlotVar*1.08
                                    set yPlotEHi = yPlotEHi/yPlotVar*1.08
                                    set yPlotVar = lg(yPlotVar)
                                    set yPlotLim = lg(yPlotLim)
                                    set yPlotTic = {-1 10} }
    if(index(xPlotStr,'pow ')==0) { set xPlotTic = {-1 10}
                                    set xPlotStr = substr(xPlotStr,4,0) }
    if(index(yPlotStr,'pow ')==0) { set yPlotTic = {-1 10}
                                    set yPlotStr = substr(yPlotStr,4,0) }
    if(index(yPlotStr,'(S_{in}-S_{out})/S_')==0) { set yPlotLim = {-4 4} }
    if(index(yPlotStr,'(S_{in}-S_{out})/S_')==0) { set yPlotLim = {-4 4} }
    if(index(yPlotStr,'(S_{in}-S_{out})/\\sigma')==0) { set yPlotLim = {-4 4} }
    if(index(yPlotStr,'(S_{in}-S_{out,uncorr})/S_')==0) { set yPlotLim = {-4 4} }
    if(index(yPlotStr,'(S_{in}-S_{out,uncorr})/S_')==0) { set yPlotLim = {-4 4} }
    if(index(yPlotStr,'(S_{in}-S_{out,uncorr})/\\sigma')==0) { set yPlotLim = {-4 4} }
    if(index(yPlotStr,'(S_{in}-S_{out,corr})/S_')==0) { set yPlotLim = {-4 4} }
    if(index(yPlotStr,'(S_{in}-S_{out,corr})/S_')==0) { set yPlotLim = {-4 4} }
    if(index(yPlotStr,'(S_{in}-S_{out,corr})/\\sigma')==0) { set yPlotLim = {-4 4} }
    # 
    !echo \\"Plot_$(yPlotStr)""_against_$(xPlotStr)"".eps\\" | sed -e 's/[^0-9a-zA-Z_.]/_/g' | perl -pe 's/[_]+/_/g' > .tmp.outname.txt
    verbose 0 data .tmp.outname.txt read outname 1.s
    verbose 1 !rm .tmp.outname.txt
    if(dimen(outname)==0) {set outname = 'go_plot_bin_scatter.eps'}
    if($?outdir) {set outname = '$outdir/'+outname}
    #echo outname = $(outname)
    # 
    load crabPlot.sm
    crabPlotOpenPS $(outname)
    location 6500 31500 18000 31500
    crabPlotDefaultPenForBox
    # 
    limits xPlotLim yPlotLim
    #limits xPlotLim yPlotArr
    ticksize $(xPlotTic[0]) $(xPlotTic[1]) $(yPlotTic[0]) $(yPlotTic[1])
    box
    # 
    crabPlotDefaultPenForTitle
    #xlabel $(xPlotStr)
    relocate $($fx1+0.50*($fx2-$fx1)) $($fy1-0.195*($fy2-$fy1))
    putlabel 5 $(xPlotStr)
    #ylabel $(yPlotStr)
    relocate $($fx1-0.165*($fx2-$fx1)) $($fy1+0.5*($fy2-$fy1))
    angle 90
    putlabel 5 $(yPlotStr)
    angle 0
    # 
    crabPlotDefaultPenForPoints
    ptype 4 1 expand 0.75 lweight 1.5
    points xPlotArr yPlotArr
    # 
    crabPlotDefaultPenForConnect
    ltype 1
    do igp=0,dimen(xPlotEdg)-1 {
        rel $(xPlotEdg[$igp]) $fy1
        draw $(xPlotEdg[$igp]) $fy2
    }
    rel $fx1 0 draw $fx2 0
    # 
    crabPlotDefaultPenForPoints
    expand 3.5
    ctype dodgerblue
    points xPlotVar yPlotVar
    #error_y xPlotVar yPlotVar yPlotErr
    errorbar xPlotVar yPlotVar yPlotELo 4
    errorbar xPlotVar yPlotVar yPlotEHi 2
    ctype default
    # 
    crabPlotClosePS
    !rm $outdir"/*.eps" 2>/dev/null
    !rm $outdir"/*.pdfmarks" 2>/dev/null
    !rm $outdir"/*.pdfconverts" 2>/dev/null


go_save_bin_scatter 03
    # 
    define check_vectors 1
    foreach var {xBinLower xBinUpper xBinValue yBinValue yBinError yBinErrLo yBinErrHi zBinValue zBinError zBinErrLo zBinErrHi xBinNumber} {
        if(!is_vector($var)) {
            print 'Error! Vector $var does not exist!\n' {}
            define check_vectors 0
        }
    }
    if($check_vectors==0) {return}
    # 
    set xPlotStr = <$1> # $1 and $2 must be quoted by double-quotes
    set yPlotStr = <$2> # $1 and $2 must be quoted by double-quotes
    set zPlotStr = '(S_{in}-S_{out})'
    set S_in_Str = 'S_{in}'
    set S_out_Str = 'S_{out}'
    set S_err_Str = 'S_{err}'
    # 
    if(index(xPlotStr,'pow ')==0) { set xPlotStr = substr(xPlotStr,4,0) }
    if(index(yPlotStr,'pow ')==0) { set yPlotStr = substr(yPlotStr,4,0) }
    # 
    !echo \\"Table_$(yPlotStr)""_against_$(xPlotStr)"".txt\\" | sed -e 's/[^0-9a-zA-Z_.]/_/g' | perl -pe 's/[_]+/_/g' > .tmp.outname.txt
    verbose 0 data .tmp.outname.txt read outname 1.s
    verbose 1 !rm .tmp.outname.txt
    if(dimen(outname)==0) {set outname = 'go_save_bin_scatter.txt'}
    if($?outdir) {set outname = '$outdir\"/\"'+outname}
    #echo outname = $(outname)
    # 
    define print_noheader 1
    set yPlotErrStr = 'Scatter'
    set yPlotELoStr = 'ScatterL68'
    set yPlotEHiStr = 'ScatterH68'
    set zPlotErrStr = '(S_in-S_out)_Scatter'
    set zPlotELoStr = '(S_in-S_out)_ScatterL68'
    set zPlotEHiStr = '(S_in-S_out)_ScatterH68'
    set xPlotLowerStr = 'Lower'
    set xPlotUpperStr = 'Upper'
    set xBinNumberStr = 'Number'
    print  $(outname) '\# %18s %20s %20s %30s %20s %20s %20s %20s %25s %25s %25s %20s\n' {xPlotLowerStr xPlotUpperStr xPlotStr yPlotStr yPlotErrStr yPlotELoStr yPlotEHiStr zPlotStr zPlotErrStr zPlotELoStr zPlotEHiStr xBinNumberStr}
    print +$(outname) '\# \n' {}
    print +$(outname) '%20g %20g %20g %30g %20g %20g %20g %20g %25g %25g %25g %20g\n' {xBinLower xBinUpper xBinValue yBinValue yBinError yBinErrLo yBinErrHi zBinValue zBinError zBinErrLo zBinErrHi xBinNumber}
    define print_noheader 0
    # 
    # 
    !echo \\"Data_$(yPlotStr)""_against_$(xPlotStr)"".txt\\" | sed -e 's/[^0-9a-zA-Z_.]/_/g' | perl -pe 's/[_]+/_/g' > .tmp.outname.txt
    verbose 0 data .tmp.outname.txt read outname 1.s
    verbose 1 !rm .tmp.outname.txt
    if(dimen(outname)==0) {set outname = 'go_save_bin_scatter_data.txt'}
    if($?outdir) {set outname = '$outdir\"/\"'+outname}
    #echo outname = $(outname)
    # 
    define print_noheader 1
    set idStr = 'id'
    load checkVectorSize.sm
    if(!checkVectorSize(id,xArray,yArray)) {exit}
    print  $(outname) '\# %18s %20s %20s %20s %20s %30s %20s\n' {idStr S_in_Str S_out_Str S_err_Str xPlotStr yPlotStr zPlotStr}
    print +$(outname) '\# \n' {}
    print +$(outname) '%20.0f %20g %20g %20g %20g %30g %20g\n' {id S_in S_out df xArray yArray zArray}
    define print_noheader 0



check_outliers
    set coo = ((S_in-S_out)/S_in > 0.3) && (fpeakSNR>10)
    set cid = id if(coo)
    print $outdir"/check_outliers.txt" '%.0f\n' {cid}
    
    # check highest fpeakSNR sources
    set coo = (fpeakSNR>100)
    if(sum(coo)>0) {
        set cid = id if(coo)
        set coo_fpeakSNR = fpeakSNR if(coo)
        set coo_sim_alma_image_STR = sim_alma_image_STR if(coo)
        sort {coo_fpeakSNR coo_sim_alma_image_STR cid}
        foreach var {coo_fpeakSNR coo_sim_alma_image_STR cid} { set $var = reverse($var) }
        print $outdir"/check_outliers_fpeakSNR_GT_100.txt" '%15.0f %15g   %s\n' {cid coo_fpeakSNR coo_sim_alma_image_STR}
    }
    
    # check highest fpeakSNR sources
    
    set coo_abs_Sdiff = abs((S_in-S_out)/S_in)
    set coo = (fpeakSNR>10 && coo_abs_Sdiff>1.0)
    if(sum(coo)>0) {
        set cid = id if(coo)
        set coo_fpeakSNR = fpeakSNR if(coo)
        set coo_Sdiff = (S_in-S_out)/S_in if(coo)
        set coo_alma_image_STR = sim_alma_image_STR if(coo)
        set coo_repetition_STR = sim_repetition_STR if(coo)
        sort {coo_fpeakSNR coo_Sdiff coo_alma_image_STR coo_repetition_STR cid}
        foreach var {coo_fpeakSNR coo_Sdiff coo_alma_image_STR coo_repetition_STR cid} { set $var = reverse($var) }
        print $outdir"/check_outliers_fpeakSNR_GT_10_and_coo_abs_Sdiff_GE_1.txt" '%15.0f %15g %15g %40s   %-14s\n' {cid coo_fpeakSNR coo_Sdiff coo_alma_image_STR coo_repetition_STR}
    }



go_corr_by_param 01
    # 
    # check
    if(!$?1) {print 'Error! \$1 is not given!\n' {} exit}
    if(!$?outdir) {print 'Error! \$outdir is not defined!\n' {} exit}
    if(!is_vector(S_peak)) {print 'Error! S_peak is not set!\n' {} exit}
    if(!is_vector(S_out)) {print 'Error! S_out is not set!\n' {} exit}
    if(!is_vector(df)) {print 'Error! df is not set!\n' {} exit}
    if(!is_vector(Maj)) {print 'Error! Maj is not set!\n' {} exit}
    if(!is_vector(beam_maj)) {print 'Error! beam_maj is not set!\n' {} exit}
    # 
    # correct by param
    if('$1' == 'MajBeam') {
        data $outdir"/Table_S_in_S_out_S_in_against_MajBeam.txt"
    }
    if('$1' == 'fpeakSNR') {
        data $outdir"/Table_S_in_S_out_S_in_against_peak_SNR.txt"
    }
    read {X_Param 3 X_Bias 4 X_ScatterL68 6 X_ScatterH68 7}
    set Y_Param = ($1)
    vecminmax X_Param X_Param_Min X_Param_Max
    define X_Bias_IMin 0
    define X_Bias_IMax $(dimen(X_Bias)-1)
    interp2 X_Param X_Bias Y_Param Y_Bias
    interp2 X_Param X_ScatterL68 Y_Param Y_ScatterL68
    interp2 X_Param X_ScatterH68 Y_Param Y_ScatterH68
    set Y_Bias = (Y_Param<$X_Param_Min) ? X_Bias[$X_Bias_IMin] : Y_Bias # deal with interpolation at the edges, for flux bias
    set Y_Bias = (Y_Param>$X_Param_Max) ? X_Bias[$X_Bias_IMax] : Y_Bias # deal with interpolation at the edges, for flux bias
    # 
    set fpeak_uncorr = S_peak
    set fpeak_corr = fpeak_uncorr / (1 - Y_Bias)
    set S_peak = fpeak_corr
    # 
    set f_uncorr = S_out
    set f_corr = f_uncorr / (1 - Y_Bias)
    set S_out = f_corr
    # 
    set Y_Scatter = (Y_ScatterL68>Y_ScatterH68) ? Y_ScatterL68 : Y_ScatterH68 
    # (S_in - S_out) / S_in = Y_Scatter
    # (S_in - S_out) / err = 1.0
    # err / S_in = Y_Scatter
    # assuming S_out = S_in
    # so err = S_out * Y_Scatter
    set df_uncorr = df
    set df_corr = f_corr * Y_Scatter
    set df = df_corr














